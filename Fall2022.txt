#separator:tab
#html:true
statistics&nbsp;	The discipline that concerns collection, organization, analysis, interpretation, and presentation of data.
data frame	a single object joined with disparate types of data; in a data frame, each column is a variable, each row is an observation.
Variables/Data	[latex]<br>Can be either:<br>\begin{itemize}<br>\item Quantitative (Numerical - variable can take&nbsp; a wide range of numerical values)<br>\begin{itemize}<br>\item Discrete - <br><br>are countable in a finite amount of time. For example, you can count the change in your pocket. You can count the money in your bank account. You could also count the amount of money in everyone’s bank accounts. It might take you a long time to count that last item, but the point is—it’s still countable.<br><br>\item Continuous -&nbsp;<br><br><div>would (literally) take forever to count. In fact, you would get to “forever” and never finish counting them. For example, take age. You can’t count “age”.<strong>&nbsp;Why not?</strong>&nbsp;Because it would literally take forever. For example, you could be:<br>25 years, 10 months, 2 days, 5 hours, 4 seconds, 4 milliseconds, 8 nanoseconds, 99 picosends…and so on.</div><br>\end{itemize}<br>\item Qualitative (Categorical)<br>\begin{itemize}<br>\item Nominal (Unordered)<br>\item Ordinal (Ordered)<br>\end{itemize}<br>\end{itemize}<br>[/latex]<br>
qualitative data chart used	bar chart/pie chart
quantitative data chart used	histogram
names(dataFrameName) - R cmd	extract variable names
length(names(dataFrameName)) - R cmd	to count the numbers of variables
table(dataFrameName$variableName) - R cmd	to get counts/frequency of different observations of a variable.
barplot(table(dataFrameName$variableName)) - R cmd	generate a bar chart of a variable
dataFrameName$variableName - R cmd	to extract observations under the variable (a column)
hist(dataFrameName$variableName)	to generate a histogram of a variable
relative-frequency histogram	when comparing two data sets, where the vertical scale depends on the percentage
"symbol ""//"" in histogram - R"	used to indicate that the zero point is not in its usual position at the intersection of the horizontal and vertical axes.
smooth curve - R histogram	helps identify the shape of a distribution.
difference between bar chart &amp; histogram	[latex]<br>Bar chart<br>\begin{itemize}<br>\item Equal space between every two consecutive bars<br>\item The x-axis can represent anything<br>\end{itemize}<br>Histogram<br>\begin{itemize}<br>\item No space between two consecutive bars. Attached.<br>\item The x-axis represents numerical data.<br>\end{itemize}<br>[/latex]
measures of center	median and mean (average)
measures of spread (variability)	interquartile range, standard deviation
descriptive statistics	computed from values in a sample in order to summarize the sample data
measures of center: median	Definition: the middle values in this ordered list. Divide the bottom 50% of the data from the top 50%<br><br>Methods: Put the data in order, then choose the central value (Average the two central values of the total number of data is even).
Measures of center: mean (average)	"[latex]<br>Definition: The sample mean $\bar{x}$ (""x bar"") can be computed as the sum of the observed values divided by the number of observations:<br>\begin{equation*}<br>\bar{x}=\frac{\sum_{i=1}^{n} x_{i}}{n}=\frac{x_1+x_2\cdots x_n}{n}<br>\end{equation*}<br><br>where $x_1$, $x_2$, $\cdots$, $x_n$ represent the $n$ observed values.<br>[/latex]"
Meausres of spread/variability: Interquartile Range	[latex]<br>First order your data from least to greatest before calculating IQR.<br><br>\begin{itemize}<br>\item Interquartile Range $\Leftarrow$ Quartile $\Leftarrow$ Perctentiles<br>\item Quartiles are the most commonly used percentiles<br>\item $IQR=Q_3 - Q_1$<br>\end{itemize}<br>Where:<br>\begin{itemize}<br>\item $Q_1$, first/lower quartile<br>-&nbsp;Lower quartile is the median of the lower half, recall to find the median if you have an even amount of data in the lower half is, $\frac{a+b}{2}$<br>\item $Q_2$, second/middle quartile<br>-&nbsp;The median of the whole data set is considered the second quartile $Q_2$<br>\item $Q_3$, third/upper quartile<br>- The upper quartile, or third quartile $Q_3$, is the value under which 75%, just find the median of the upper half.<br>\end{itemize}<br>[/latex]
Measures of spread/variability: standard deviation (SD)	[latex]<br>Definition: For a given data set $x_1$, $x_2$, $\cdots$, $x_n$, the SD is defined as:<br><br>\begin{equation*}<br>s=\sqrt{\frac{\sum_{i=1}^{n} (x_i - \bar{x})^2}{n-1}}<br>\end{equation*}<br>The variance is $s^2$<br><br>Note: We divided by $n-1$, rather than $n$, when computing a sample standard deviation/variance.<br>[/latex]
proposition	a sentence which is either true or false (but not both)
predicates	is a sentence that contains a finite number of variables and becomes a statement when specific values are substituted for the variables.
free variables	the symbols in a predicate that need to be given values in order to obtain a&nbsp;<b>proposition.</b>
logical connectives	helps bring simpler statements together to build up a bigger statement.
disjunction	When only one thing needs to be true, i.e. P or Q
conjunction	When both things need to be true for the statement to be true, i.e. P and Q
implication	an implication is the assertion that if one particular statement is true then another particular statement is true.
hypothesis (antecedent)	The statement coming before the conclusion in an implication.
conclusion (consequent)	statement coming after the hypothesis in an implication statement
conditional statement	An implication, but it is not called this because of the link between causation and implication in everyday speech. [$]P\Rightarrow Q[\$]
universal statement	when a predicate leads to a true proposition whatever value is assigned (from a set) to the free variable(s).
existence statement	it claims that there is a value of [$]x[/$] for which the statement is true.
converse	Example:<br><br>[$]P \Rightarrow Q[/$] is the conditional statement and its <b>converse</b> is [$]Q \Rightarrow [/$]
if and only if	We use this when both the original conditional statement and its converse hold.
proposition vs theorem	Propositions are usually used for results of less significance than theorems.
axioms	Statements which we are assuming to be true.<br><br>We do mathematics by exploring what follows from the truth of these axioms using certain accepted rules of deduction.
direct proof	[latex]<br>A proof of the form: $P\Rightarrow Q$ where we can assume $P$ to be true in order to prove $Q$.<br>[/latex]
contradiction	[latex]<br>A statement of the form '$P$ and (not $P$)'<br>[/latex]
contrapositive	[latex]<br>If we have the statement $P\Rightarrow Q$ then its \textbf{contrapositive} will be $(not\ Q)\Rightarrow (not\ P)$.<br><br>[/latex]
procedural programming	- Mathematical functions, characters, and strings<br>- Selections and loops<br>- Methods<br>- Single-dimension arrays and multidemnsional arrays<br>- No objects
selections	<ul><li>Relational operators(e.g., less than, equal to)</li><li>Logical operators(e.g., not, and, or)</li><li>if statements</li><li>if-else statements</li><li>switch statements</li></ul>
Loops	<ul><li>while loop</li><li>do-while loops</li><li>for loops</li></ul>
methods	a collection of statements that are grouped together to perform an operation
array	a data structure that represents a collection of the same types of data
object oriented programming	<ul><li>Data and operations on data are in an object</li><li>Organizes programs like the real world<br>All objects are associated with both attributes and activities</li></ul>
classes	constructs that define objects of the same type
Class abstraction and encapsulation	<ul><li>separate class implementation from the use of the class</li><li>The creator of the class provides a description of the class and let the use know how the class can be used</li><li>The user of the class does not need to know how the class is implemented.</li><li>the detail of implementation is encapsulated and hidden from the user</li></ul>
Inheritance	<ul><li>OOP allows you to define new classes from existing classes</li><li>This is called inheritance</li><li>It enables you to define a general class(a <b>superclass</b>) and later extend it to more specialed classes(<b>subclasses</b>)</li></ul>
Polymorphism	<ul><li>A class defines a <b>type</b></li><li>A type defined by a subclass is called a subtype, and a type defined by its superclass is called a supertype.</li><li>e.g. Circle is a subtype of GeometricObject, and GeometricObject is a supertype for Circle</li><li>Polymorphism means that a variable of a supertype can refer to a subtype object.</li></ul>
Abstract Classes	<ul><li>Sometimes, a superclass is so general it cannot be used to create objects(such a class is called an <b>abstract class</b>)</li><li>An abstract class cannot be used to create objects.</li><li>An abstract class can contain abstract methods that are implemented in <b>concrete</b> subclasses.</li><li>Just like nonabstract classes, models <b>is-a</b> relationships.<br>e.g. Circle <b>is-a</b> GeometricObject, Rectangle <b>is-a</b> GeometricObject</li></ul>
Abstract classes and interfaces	<ul><li>A superclass defines common behavior for <b>related</b> subclasses.</li><li>An <i>interface</i> can be used to define common behavior for classes, including <b>unrelated</b> classes.</li><li>Interfaces and abstract classes are closely related to each other.</li></ul>
Interfaces	<ul><li>An interface is a class-like construct that contains <b>only</b> constants and abstract methods.<br>- In many ways, an interface is similar to an abstract class, but the intent of an interface is to specify common behavior for objects.<br>- For example, you can specify that the objects are comparable and/or cloneable using appropriate interfaces.</li><li>Interfaces model <b>is-kind-of</b> relationships<br>- e.g. Fruit is-kind-of Edible<br>- e.g. Fish is-kind-of Edible</li></ul><br>
Exception handling	Exceptions are errors caused by your program and external circumstances<br>- These errors can be caught and handled by your program.
Assertion	<ul><li>An assertion is a Java statement that enables you to assert an assumption about your program</li><li>An assertion contains a Boolean expression that should be true during program execution</li><li>Assertions can be used to assure a program correctness and avoid logic errors.</li></ul>
Text I/O	In order to perform I/O, you need to create objects using appropriate Java I/O classes<br>- The objects contain the methods for reading/writing data from/to a file.
Binary I/O	Binary I/O does not involve encoding or decoding and thus is more efficient than text I/O
Recursion	<ul><li>Recursion is a technique that leads to elegant solutions to problems that are difficult to program using simple loops.</li><li>A recursive method is one that invokes itself directly or indirectly.</li></ul>
Event-driven programming	<ul><li>An event is an object created from an event source</li><li>You can write code to process events such as a button click, mouse movement, and keystrokes</li></ul>
$ whoami	shows your username
$ pwd	shows full path of your current directory
$ ls	Check your current directories content
$ touch &lt;filename&gt;	creates a new empty file in the current directory
Programs	<ul><li>Computer programs are instructions to the computer</li><li>Written using programming languages<br></li></ul>
Programming languages	<ul><li>Machine language</li><li>Assembly language</li><li>High-level language</li></ul>
Machine language	<ul><li>is a set of primitive instructions built into every computer</li><li>the instructions are in the form of binary code, so you must enter binary vodes for various instructions</li><li>programming with native machine language is a tedious process, and the programs are highly difficult to read and modify</li><li>e.g. To add two numbers, you might write an instruction in binary like this:<br>1101101010011010</li></ul>
Assembly language	<ul><li>Assembly languages were developed to make programming easier than machine languages</li><li>Since the computer cannot understand assembly language, a program called <b>assembler</b> is used to convert assembly language programs into machine code.</li><li>e.g. to add two numbers, you might write an instruction in assembly code like this:<br>ADDF3 R1, R2, R3</li></ul>
High-level language	<ul><li>High-level languages are english-like and easier to learn and program than assembly languages</li><li>e.g. The following is a statement that computes the area of a circle with radius 5:<br>area = 5 * 5 * 3.1415</li></ul>
Interpreting/Compiling source code	<ul><li>A program written in a high-level language is called a source program or source code</li><li>Because a computer cannot understand a source program, a source program must be translated into machine code for execution</li><li>The translation can be done using another programming tool called an interpreter or a compiler.</li></ul>
Interpreting source code	<ul><li>An interpreter reads one statement from the source code, translates it to the machine code or virtual machine code, and then executes it right away.</li><li>A statement from the source code may be translated into several machine instructions.</li></ul>
Compiling source code	<ul><li>A compiler translates the entire source code into a machine-code file, and the machine-code file is then executed.</li></ul>
Java	<ul><li>The compiler of Java is called <b>javac</b><br>Java source code is compiled into the <i>JVM</i> code called <i>bytecode</i></li><li>The interpreter of Java is called <b>java</b><br>The <i>bytecode</i> is <b>machine-independent</b> and can run on any machine that has a Java interpreter, which is part of the JVM(write once, run anywhere)</li></ul>
Anatomy of a Java program	<ul><li>Class name</li><li>Main method</li><li>Statements</li><li>Statement terminator</li><li>Reserved words</li><li>Comments</li><li>Blocks</li></ul>
Class name	<ul><li>Every Java program must have at least one class</li><li>Each class has a name</li><li>Naming convention: capitalize the first letter of each word in the name class(e.g., ComputeArea)</li></ul>
main method	<ul><li>In order to run a class, the class must contain a method naimed main</li><li>The program is executed from the main method</li></ul>
statement	<ul><li>A statement represents an action or a sequence of actions</li></ul>
public void println(String x)	Prints a string and then terminate the line. This method behaves as though it invokes print(String) and then println()
public void print(String s)	"Prints a string. If the argument is null then the string ""null"" is printed. Otherwise, the string's characters are converted into bytes according to the platforms default character encoding, and these bytes are written in exactly the manner of the <b>write(int)</b> method."
statement terminator	Every statement in Java ends with a semicolon
Reserved words	<ul><li>Reserved words or keywords are words that have a specific meaning to the compiler and cannot be used for other purposes in the program.</li><li>e.g. when the compiler sees the word class, it understand that the word after class is the name for the class</li></ul>
Comments	<ul><li>Comments make the code more readable by adding details</li><li>Implementation comments are meant for commenting out code or for comments about the particular implementation.</li><li>// comments out everything after it on the line</li><li>The comment delimiters /*...*/ comments out everything between /* and */</li></ul>
Blocks	A pair of braces in a program forms a block that groups components of a program
Special symbols	"<ul><li>{} Denotes a block to enclose statements</li><li>() Used with methods</li><li>[] Denotes an array</li><li>// Precedes a comment line.</li><li>"" "" Enclosing a string (i.e. a sequence of characters)</li><li>; Marks the end of a statement.</li></ul>"
Identifiers	<ul><li>Identifiers are the names that identify the elements such as classes, methods, and variables in a program</li><li>An identifier is a sequence of characters that consist of letters, digits, underscores (_), and dollar signs ($)</li><li>An identifier must start with a letter, an underscore(_), or a dollar sign ($)</li><li>An identifier cannot start with a digit</li><li>An identifier cannot be a reserved word</li><li>An identifier cannot be true, false, or null</li><li>An identifier can be of any length.</li></ul>
Variable and method names	Naming convention: Use lowercase. If the name consists of several words, concatenate all in one, use lowercase for the first word, and capitalize the first letter of each subsequent word in the name.
Variables	Variables are used to represent values that may be changed in the program.
Declaring variables	<ul><li>int x; <br>declare x to be an integer variable</li><li>double radius; <br>declare radius to be a double variable</li><li>char a;<br>declare a to be a character variable</li></ul>
Assignment statements	<ul><li>x=1;<br>Assign 1 to x<br></li><li>radius=1.0;<br>Assign 1.0 to radius<br></li><li>a = 'A';<br>Assign 'A' to a</li></ul>
Declaring and initializing in one step	<ul><li>int x =1;</li><li>double radius = 1.0;</li><li>char a = 'A';</li></ul>
Named constants	Naming convention: capitalize all letters in constants, and use underscores to connect words
Programming errors	<ul><li>Syntax errors<br>- Detected by the compiler</li><li>Runtime errors<br>- Causes the program to abort</li><li>Logic errors<br>- Produces incorrect result</li></ul>
Syntax errors	<ul><li>If you mistype part of a program, the compiler may issue a syntax error.<br></li><li>The message usually displays the type of the error, the line number where the error was detected, the code on that line, and the position of the error within the code.</li><li>If you see any compiler errors, then your program did not succesfully compile and the compiler did not create a .class file.</li><li><b>Semantic Errors</b>: in addition to verifying that your program is syntactially correct, the compiler checks for other basic correctness. For example, the compiler warns you each time you use a variable that has not been initialized.</li></ul>
Runtime errors	"<ul><li>Exception in thread ""main""</li></ul>"
probability	a measure of one's belief in the occurence of a future event.
empirical probability	Decide how likely something is by repeatedly doing it and seeing how often it occurs (e.g. flipping a coin)
subjective probability	Use personal belief structure to make predictions (e.g. this stock will go upward tomorrow in my opinion)
theoretical probability	structuring a random process mathematically so we can exactly determine the probability.
experiment	an action whose outcome cannot be predicted with certainty and the process by which an observation is made.
events	When an experiment is performed, it can result in one or more outcomes, which are called events.<br><br>Notations: use letters such as A, B, C, ... to represent events.<br><br>An event associated with an experiment is a subset of the sample space associated with the same experiment.
simple event	an event that cannot be decomposed
sample space	associated with an experiment is the set of consisting of all possible sample events<br><br>Notations: use S for the sample space.
probability for equally likely events	[latex]<br>Suppose an experiment has $N$ possible outcomes, all equally likely.<br><br><br>An event (E) that can occur in $f$ ways has probability $\frac{f}{N}$ occuring:<br><br><br>Probability of an event $(E) = P(E) = \frac{f}{N}$<br><br><br>NOTE: For an experiment with equally likely outcomes, probabilities are identical to relative frequenceis (or percentage)<br><br><br>By the definition, $0 \leq f \leq N$, then we have $0 \leq P(E) \leq 1$<br><br><br>$P(E)=0 \to $ event (E) can not happen $\to $ impossible event<br><br><br>$P(E)=1 \to $ event (E) must happen $\to $ certain event<br>[/latex]
Relationships among events	"[latex]<br><br>1. ""A and B"" $\Leftrightarrow ""A\cap B""$ (A intersection B)<br><br>Define events $A\cap B$ as the set of outcomes common to both events.<br><br>e.g. Let $A={1,2,3}$ and $B={3,4,5}$ then $A\cap B={3}$<br><br>2. ""A or B"" $\Leftrightarrow&nbsp;""A\cup B""$ (A union B)<br><br>Define events $A\cup B$ as the set of outcomes in either event.<br><br>3. ""not A"" $\Leftrightarrow&nbsp;""A^C""$ (A complement)<br><br>Define events $A^C$ as the complement of an event A.<br><br><br><br>[/latex]"
create a data frame - R	"<pre><b>Example:</b>

first_column &lt;- c(""value_1"", ""value_2"", ...)
second_column &lt;- c(""value_1"", ""value_2"", ...)

df &lt;- data.frame(first_column, second_column)

<b>or you can do the following:</b>
<pre>df &lt;- data.frame (first_column  = c(""value_1"", ""value_2"", ...),
                  second_column = c(""value_1"", ""value_2"", ...)
                  )

Where the <i>values</i> are the <b>observations</b> and the <i>columns</i> are the <b>variables</b>.</pre></pre>"
Mathematical Functions, characters, and strings:	<ul><li>Numerical data types(e.g., an integer)</li><li>Numeric operations(e.g., addition)</li><li>Mathematical functions (e.g., cosine)</li><li>Reading numbers from the console</li><li>Character data type (e.g. char)</li><li>Comparing and testing characters</li><li>String data type (i.e., String)</li><li>Simple string methods(e.g., number of characters in the string)</li><li>Reading a character and string from the console</li></ul>
Numerical data types	[latex]<br>\begin{center}<br>\begin{tabular}{lll}<br>Name &amp; Range &amp; Storage Size \\<br>\hline<br>byte &amp; $-2^7$ to $2^7 -1(-128$ to $127)$ &amp; 8-bit signed \\<br>short &amp; $-2^{15}$ to $2^{15} -1(-32768$ to $32767)$ &amp; 16-bit signed \\<br>int &amp; $-2^{31}$ to $2^{31} -1(-2147483648$ to $2147483647)$ &amp; 16-bit signed \\&nbsp;<br>long &amp; $-2^{63}$ to $2^{63} -1(-9223372036854775808$ to $9223372036854775807)$ &amp; 64-bit signed \\ end{tabular}<br>float &amp; NR: -3.4E+38 to -1.4E-45 PR: 1.4E-45 to 3.4E+38 &amp; 32-bit IEEE 754 \\<br>double &amp; NR: -1.79E+308 to -4.9E-324 PR: 4.9E-324 to 1.79E+308 &amp; 64-bit IEEE 754 \\<br>\end{tabular}<br>\end{center}<br>[/latex]
Number literals	A literal is a constant value that appears directly in the program<br><br>e.g.<br><br>int i = 34;<br>long x = 100000;<br>double d = 5.0 + 1.0;<br><br>where the numbers to the right of the equal signs are literals.
Integer literals	<ul><li>An integer literal can be assigned to an integer variable as long as it can <b>fit</b> into the variable</li><li>A compilation error will occur if the literal is too large for the variable too hold</li><li>An integer literal is assumed to be of the int type, whose value is between&nbsp;[latex]$-2^{31} to 2^{31}-1$[/latex]</li><li><b>To denote an integer literal of the long type, append it with the letter L or l</b></li></ul>
Floating-point literals	<ul><li>Floating-point literals are written with a decimal point</li><li>By default, a floating-point literal is treated as a <b>double type</b> value e.g., 5.0 is considered a double value not a float value</li><li>You can make a number a float by <b>appending</b> the letter f or F, and make a number a double by appending the letter d or D</li></ul>
Scientific notation	<ul><li>Floating-point literals can also be specified in scientific notation:<br>- e.g. 1.23456e+2 (same as 1.23456e2) is equivalent to 123.456, and 1.23456e-1 is equivalent to 0.0123456</li><li>E or e represents an exponent</li></ul>
double vs float	<ul><li>The double type values are more accurate than the float type values.</li><li>Where a double can display up to 16 digits and float only 7 digits.</li></ul>
Floating-point accuracy	<ul><li>Calculations involving floating-point numbers are approximated because these numbers are not stored with complete accuracy</li><li>Whereas integers are stored precisely</li></ul>
Integer division	<b>Warning</b>: resulting fractionak part is truncated, not rounded up.
Remainder operator	<ul><li>e.g. an even number % 2 is always 0 and an odd number % 2 is always 1.<br>You can use this property to determine whether a number is even or odd</li></ul>
increment and decrement operators	<ul><li>++var is preincrement, meaning increment var by 1 and use the new var value in the statement.</li><li>var++ is postincrement, i.e. increment var by 1, but use the original var (before it was incremented) in the statement</li><li>e.g. Assume i=1<br>int j = ++i; // j is 2, i is 2<br>int j = i++; // j is 1, i is 2</li><li>This also applies to --var and var--</li></ul>
Conversion rules	<ul><li>When performing a binary operation involving two operands&nbsp; of different types, Java automatically converts the operand based on the following rules<br>- If one of the operands is double, the other is converted into double<br>- Otherwise, if one of the operands is float, the other is converted into float<br>- If one of the operands is long, the other is converted into long<br>- Otherwise, both operands are converted into int</li></ul>
Type casting	<ul><li><b>Implicit casting</b><br>double d=3; (type widening)<br></li><li><b>Explicit casting</b><br>int i = (int)3.0; (type narrowing)<br>int i = (int)3.9; (fraction part is truncated, not rounded</li></ul>
Augmented assignment operators	Lec3, pg 14
Operator precedence	Lec 3, pg 18
Operator associativity	<ul><li>When two operators with the same precedence are evaluated, the associativity of the operators determines the order of evaluation<br></li><li>All <b>binary operators</b> except assignment operators are <b>left-associative</b><br>a-b+c-d is equivalent to ((a-b)+c)-d</li><li><b>Assignment operators</b> are <b>right-associative</b><br>a = b += c = 5 is equivalent to a = (b += (c = 5))</li></ul>
Operator precedence and associativity	<ul><li>The expression in the paranthesis is evaluated first</li><li>When evaluating an expression without paranthesis, the operators are applied&nbsp; according to the precedence rule and the associativity rule.</li><li>If operators with the same precedence are next to each other, their associativity determines the order of evaluation.</li></ul>
Reading numbers from the console	"<ol><li>Create a scanner object<br>Scanner input = new Scanner(System.in);</li><li>Use the method nextDouble() to obtain a double value.<br><b>Example:</b><br>System.out.print(""Enter a double value: "");<br>Scanner <i>input</i> = new Scanner(System.in);<br>double d = <i>input</i>.nextDouble();<br><br>More methods like nextInt(), nextLong() etc... on Lec 3, pg. 22</li></ol>"
Explicit import and implicit import	<ul><li>At top of source file<br><br>import java.util.Scanner; // Explicit import<br><br>import java.util.*; // Implicit import</li></ul>
Mathematical functions	<ul><li>Java provides many useful methods in the Math class for performing common mathematical functions</li><li>Math class constants<br>PI<br>E<br></li><li>Math class methods<br>- Trigonometric methods<br>- Exponent methods<br>- Rounding methods<br>- min, max, abs, and random methods</li></ul>
Trigonometric methods	<ul><li>Math.toDegrees(radians)</li><li>Math.toRadians(degrees)</li><li>Math.sin(radians)</li><li>Math.cos(radians)</li><li>Math.tan(radians)</li><li>Math.acos(a)</li><li>Math.asin(a)</li><li>Math.atan(a)</li></ul>
Exponent methods	<ul><li>Math.exp(a)</li><li>Math.log(a)</li><li>Math.log10(a)</li><li>Math.pow(a, b)</li><li>Math.sqrt(a)</li></ul>
Rounding methods	<ul><li>Math.ceil(x)<br>nearest integer not less than x</li><li>Math.floor(x)<br>nearest integer not greater than x</li><li>Math.rint(x)<br>x is rounded to its nearest integer. If x is equally close to two integers, the even one is returned.<br>e.g. if x = 3.4, Math.rint(x) returns 3.<br></li><li>Lec 3, pg 27 for more</li></ul>
min, max, abs, and random methods	<ul><li>Math.min(a, b)</li><li>Math.max(a, b)</li><li>Math.abs(a)</li><li>Math.random()<br>- returns a random double value in the range [0.0, 1.0]</li></ul>
char data type	<ul><li>char letter = 'A'; // ASCII</li><li>char numChar = '4'; // ASCII</li><li>char letter = '\u0041'; // Unicode<br></li><li>char numChar = '\u0034'; // Unicode</li></ul>
Common and special characters	Lec 3, pg 30
Comparing and testing characters	"If (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')<br>&nbsp; &nbsp; System.out.println(ch + "" is an uppercase letter)<br><ul><li>Methods in the char class<br>isDigit(ch)<br>isLetter(ch)<br>isLetterofDigit(ch) // Returns true if letter or digit<br>isLowerCase(ch)<br>isUpperCase(ch)<br>toLowerCase(ch)<br>toUpperCase(ch)</li></ul>"
Casting between char and numeric data types	int i = 'a'; // same as int i = (int)'a';<br><br>char c = 97; // same as char c = (char)97;
String type	"<ul><li>The char type only represents one character</li><li>To represent a string of characters, use the String type</li><li>String is a predefined class in the Java library (just like the System class and Scanner class)<br>String message = ""Welcome to Java"";</li><li>The String type is <b>not</b> a primitive type; it is known as a <b>reference type</b>.<br>- Any Java class can be used as a reference type for a variable</li></ul>"
Simple String methods	<ul><li>length()</li><li>charAt(index) // return char at index</li><li>concat(s1) // concatenate with string s1</li><li>toUpperCase()</li><li>toLowerCase()</li><li>trim() // returns a new string w/ whitespace characters trimmed on both sides.</li><li>These methods can only be invoked from a specific string instance<br>- These methods are called instance methods</li></ul>
Instance methods vs static methods	<ul><li>These methods can only be invoked from a specific string instance<br>- These methods are called instance methods<br>- The syntax to invoke an instance method is<br>referenceVariable.methodName(arguments)</li><li>A non-instance method is called a static method<br>- A static method can be invoked without using an object(i.e., they are not tied to a specific object instance)<br>- The syntax to invoke a static method is<br>ClassName.methodName(arguments)<br>- For example, all the methods defined in the Math class are static methods</li></ul>
Getting characters from a string	"String message = ""Welcome to Java"";<br><br>System.out.println(""The first character in message is "" + <b>message.charAt(0)</b>);<br><br>Which prints out:<br><br>""The first character in message is W"""
String concatenation	String s3 = s1.concat(s2);<br>String s3 = s1 + s2;<br><br>// Both of these concatenation methods are equivalent
Reading a string from the console	"Scanner input = new Scanner(System.in);<br><br>System.out.print(""Enter three words separated by spaces: "");<br><br>String s1 = input.next();<br>String s2 = input.next();<br>......"
Reading a character from the console	Scanner input = new Scanner(System.in);<br><br>String s = input.nextLine();<br>char ch = s.chartAt(0);
Comparing strings	[latex]<br>\begin{center}<br>\begin{tabular}{ll}<br>Method &amp; Description \\<br>equals(s1) &amp; Returns true if this string is equal to string s1 \\<br>equalsIgnoreCase(s1) &amp; Returns true if this string is equal to string s1, it is case insensitive. \\<br>compareTo(s1) &amp; Returns an integer greater than 0, equal to 0, or less than 0 to indicate whether this string is greater than, equal to, or less than s1. \\<br>compareToIgnoreCase(s1) &amp; Same as compareTo except that the comparison is case insensitive. \\<br>startsWith(prefix) &amp; Returns true if this string starts with the specified prefix \\<br>endsWith(suffix) &amp; Returns true if this string ends with the specified suffix. \\<br>\end{tabular}<br>\end{center}<br>[/latex]
Substrings	[latex]<br>\begin{center}<br>\begin{tabular}{ll}<br>Method &amp; Description \\<br>substring(beginIndex) &amp; Returns this strings substring that begins with the character at the specified <b>beginIndex</b> and extends to the end of the string. \\<br>substring(beginIndex, endIndex) &amp; Returns this strings substring that begins at the specified beginIndex and extends to the character at index endIndex-1. Note that the character at endIndex is not part of the substring. \\<br>\end{tabular}<br>\end{center}<br>[/latex]
Finding a character or a substring in a string	[latex]<br>\begin{center}<br>\begin{tabular}{ll}<br>Method &amp; Description \\<br>indexOf(ch) &amp; Returns the index of the first occurrence of ch in the string. \\<br>indexOf(ch, fromIndex) &amp; Same as above excpet start at certain index \\<br>indexOf(s) &amp; Returns the index of the first occurrence of string s in this string. \\<br>indexOf(s, fromIndex) &amp; Same as above except start at a certain index. \\<br>lastIndexOf(ch) &amp; Returns the index of the last occurence of ch in the string. \\<br>lastIndexOf(ch, fromIndex) &amp; self-explanatory \\<br>lastIndexOf(s) &amp; self-explanatory \\<br>lastIndexOf(s, fromIndex) &amp; self-explantory \\<br>\end{tabular}<br><br>Example:<br><br>int k = s.indexOf(' ');<br>String firstName = s.substring(0, k);<br>String lastName = s.substring(k + 1);<br><br>\end{center}<br>[/latex]
Conversion between strings and numbers	"int intValue = Integer.parseInt(intString);<br>double doubleValue = Double.parseDouble(doubleString);<br><br>String s = number + """";"
Formatting output	<ul><li>Use the printf statement<br>System.out.printf(format, items);</li><li>Where format is a string that may consist of substrings and format specifiers<br>- A format specifier specifies how an item should be displayed<br>- Each specifier begins with a percent sign<br>- An item may be a numeric value, character, Boolean value, or a string.</li></ul>
Common specifiers	"[latex]<br>\begin{center}<br>\begin{tabular}{ll}<br>Specifier Output &amp; Example \\<br>%b &amp; a boolean value &amp; true or false \\<br>%c &amp; a character &amp; 'a' \\<br>%d &amp; a decimal integer &amp; 200 \\<br>%f &amp; a floating-point number &amp; 45.460000 \\<br>%e &amp; a number in standard scientific notation &amp; 4.556000e+01 \\<br>%s &amp; a string &amp; ""Java is cool"" \\<br>\end{tabular}<br>\end{center}<br>[/latex]"
Mutually exclusive/disjoint events	[latex]<br>\textbf{Definition:} Two or more events are called mutually exclusive events (or disjoint events) if no two of them have outcomes in common.<br><br>That is, $A\cap B= \emptyset$<br><br><br>\textbf{The special addition rule:}<br><br><br>$P(A\cup B)=P(A)+P(B)$<br><br><br>\textbf{The complementation rule:}<br><br><br>$P(A^C)=1-P(A)$<br><br><br>\textbf{The general addition rule:}<br><br><br>$P(A\cup B)=P(A)+P(B)-P(A\cap B)$<br><br>[/latex]
Conditional probability	"[latex]<br>Definition: The conditional probability of an event A, given that an event B has occured, is equal to:<br><br>\begin{equation*}<br>P(A|B)=\frac{P(A\cap B)}{P(B)}<br>\end{equation*}<br><br>Provided $P(B)&gt;0$.<br><br>(The symbol $P(A|B)$ is read ""probability of A given B"")<br><br>Example: Find the probability of rolling a prime number on a fair six-sided die if you already know the results are even.<br><br>Solution: Let $A(B)$ be the event of rolling a prime (an even) number.<br><br>This problem is asking for $P(A|B)$.<br>According to the definition above, we have the sample space $S=\{ 1,2,3,4,5,6 \}$, $A=\{ 2,3,5 \}$, $B=\{ 2,3,6 \}$, $A\cap B=\{ 2 \}$<br><br>Then, we have<br><br>$P(B)=\frac{1}{2}$, $P(A\cap B)=\frac{1}{6}$. We have $P(A|B)=\frac{P(A\cap B)}{P(B)}=\frac{1}{3}$.<br>[/latex]"
Independent events	[latex]<br>Definition: Two events $A$ and $B$ are said to be \textbf{independent} if any one of the following holds,<br><br>\begin{equation*}<br>\begin{split}<br>P(A|B)&amp;=P(A) \\<br>P(B|A)&amp;=P(B) \\<br>P(A\cap B)&amp;=P(A)P(B) \\<br>\end{split}<br>\end{equation*}<br><br>Otherwise, the events are said to be \textbf{dependent}.<br><br>You only need to \textbf{remember one} of them, e.g. if events $A$ and $B$ are said to be independent, we have $P(A\cap B)=P(A)P(B)$.<br><br>By the definition of conditional probability $P(A|B)=\frac{P(A\cap B)}{P(B)}=\frac{P(A)P(B)}{P(B)}=P(A)$,<br><br>$P(B|A)=\frac{P(B\cap A)}{P(A)}=\frac{P(B)P(A)}{P(A)}=P(B)$<br>[/latex]
How to prove the independence between two events?	[latex]<br>\textbf{Example:}<br><br>Consider the following events in the toss of a fair die,<br>A: Observe an odd number<br>B: Observe a 1 or 2.<br><br>\textbf{Solution:}<br><br>In order to prove the independence/dependence, we use the definition. Any of those three can be applied here. e.g., we use $P(A\cap B)=P(A)P(B)$.<br><br>Based on this problem:<br><br>$P(A)=\frac{1}{2}$<br><br>$P(B)=\frac{1}{3}$<br><br>$P(A\cap B)=\frac{1}{6}$<br><br>We have $P(A)P(B)=\frac{1}{2}\cdot \frac{1}{3}=\frac{1}{6}=P(A\cap B)$.<br><br>By the definition, $A$ and $B$ are two independent events.<br>[/latex]
With/Without replacement	"[latex]<br>In an experiment, certain strategies are described as ""with replacement"" or ""without replacement"" when we do sampling. This will lead to a different solution.<br><br>\textbf{Experiment}: Randomly select a billiards ball from the six TWICE,<br><br>$A$: Observe an odd number in the first select.<br>$B$: Observe an odd number in the second select.<br><br>Find $P(A\cap B)$.<br><br>\textbf{With replacement case:} A and B are not related, so A and B are independent.<br><br>$P(A)=P(B)=\frac{1}{2}, by independent event definition:<br><br>$P(A\cap B)=\frac{1}{2}\cdot \frac{1}{2}=\frac{1}{4}$<br><br>\textbf{Without replacement case:} A and B are related, so A and B are dependent.<br><br>$P(A)=frac{1}{2}$, $P(B|A)=\frac{2}{5}$, by conditional probability definition, we have:<br><br>$P(A\cap B)=P(B|A)\cdot P(A)=\frac{1}{2}\cdot \frac{2}{5}=\frac{1}{5}.<br><br>[/latex]"
R Example	We can use R to do simulation related to <b>with/without replacement sampling</b>.<br><br>The function <b>sample</b> to selects a certain number of elements from a sample size (vector) under a given replacement strategy.<br><br>(R example in slides, last pg)
visualizations of data	[latex]<br>To better undertand data, we do exercises by using<br><br>\begin{enumerate}<br>\item Contingency Table<br><br>Joint probability<br><br>Marginal probability<br>\item Tables Venn Diagrams<br><br>Joint probability<br><br>Marginal probability<br>\item Trees<br><br>Conditional probability<br>\end{enumerate}<br><br>\textbf{Example}<br><br>The contingency table shows the distribution of books on a bookcase based on whether they are non-fiction or fiction and hardcover or paperback. pg.4<br><br>\textbf{Example}<br><br>Let A be the event the book is fiction, let B be the event the book is paperback<br><br>From the diagram in the slides the universal set U is equal to 95.<br><br>1) Find the joint probability of A and B, $P(A\cap B)$<br><br>$|A|=72$<br><br>$|B|=67$<br><br>$|A\cap B|=59$<br><br>$P(A \cap B) =P(59)=\frac{59}{95}=0.62$<br><br>2) Find the marginal probability of $A$, $P(A)$:<br><br>$P(A)=\frac{72}{95}=0.76$<br><br>3) Find the conditional probability of $B$ given $A$, $P(B|A)$:<br><br>$P(B|A)=\frac{P(A\cap B)}{P(B)}=\frac{0.62}{0.70}=0.86$<br><br>Trees can also be applied using this example. Diagram on pg.7 of slides.<br><br>[/latex]
Bayes Theorem	[latex]<br>By the definition of conditional probability:<br><br>\begin{equation*}<br>P(A|B)=\frac{P(A \cap B)}{P(B)} P(A\cap B)=P(A|B)P(B)<br>P(B|A)=\frac{P(B \cap A)}{P(A)} P(B\cap A)=P(B|A)P(A)<br>\end{equation*}<br><br>\textbf{Simple Bayes Theorem}<br><br>If we know $P(A)$ then $P(B|A)=\frac{P(A|B)P(B)}{P(A)}$<br><br>where<br><br>$P(B|A)P(A)=P(A|B)P(B)$<br><br>\textbf{Advanced Bayes Theorem}<br><br>If $P(A)$ is unknown then: $P(B|A)=\frac{P(A|B)P(B)}{P(A|B^C)P(B^C)+P(A|B)P(B)}$<br><br>Where the denominator for both the simple and advanced version is called the \textbf{Law of Total Probability}.<br><br>\textbf{Example}<br>\newline<br><br>An electronic fuse is produced by five production lines in a manufacturing operation. The fuses are costly, are quite reliable, and shipped to suppliers in 100-unit lots. Because testing is destructive, most buyers of the fuses test only a small number of fuses before deciding to accept or reject lots of incoming fuses.<br><br>All five production lines produce fuses at the same rate and normally produce only 2% defective fuses, which are dispersed randomly in the output. Unfortunately, production line 1 suffered mechanical difficulty and produced 5% defectives during the month of March. This situation became known to the manufacturer after the fuses has been shipped. A customer recieved a lot produced in March and tested three fuses. One failed. What is the probability that the lot was produced on line 1? What is the probability that the lot came from one of the four other lines?<br>\newline<br><br>\textbf{Solution:}<br><br>Let $A$ denote the event that a fuse was defective; let $B$ denote that a fuse was drawn from line $1$.<br><br>We have: $P(B)=0.2$, $P(A|B)=3(0.05)(1-0.05)^2=0.135$<br><br>Similarly, we have:<br><br>$P(B^C)=0.8$,<br><br>$P(A|B^C)=3(0.02)(1-0.02)^2=0.058$<br><br>By \textbf{Law of the Total Probability}<br><br>$P(A)=P(A|B^C)P(B^C)+P(A|B)P(B)$<br><br>$P(A)=0.058\cdot 0.8+0.135\cdot 0.2=0.0734$<br><br>By the \textbf{simple Bayes' Theorem},<br><br>$P(B|A)=\frac{P(A|B)P(B)}{P(A)}=\frac{0.135\cdot 0.2}{0.0734}=0.368$<br><br>What is the probability that the lot came from one of the four other lines?<br><br>The question itself asks $P(B^C|A)$?<br>[/latex]
Random variable	[latex]<br>\textbf{Definition:} R.V. is a \textbf{quantitative} variable whose value depends on chance. It is a random process with a numerical outcome.<br>[/latex]
Continuous and Discrete Random Variable	[latex]<br>Key features for a R.V.<br><br>\begin{itemize}<br>\item Define a symbol (capital letter) to represent the R.V.<br>\item State the support of the R.V.<br>\item The probability of each value in the support (distribution)<br>\item Important statistics, such as expected value, standard deviation, etc ...<br>\end{itemize}<br><br>\textbf{Example - FFXIV}<br><br>\begin{itemize}<br>\item Let X be the damage from a hit of the character in this example<br>\item Support is $\{ 100,120,200,240 \}$<br>\item The probability of each value in the support, respectively is $\frac{12}{20},\frac{3}{20}, \frac{4}{20}, \frac{1}{20}$<br>\end{itemize}<br>[/latex]
Expectation (Expected Value)	[latex]<br>\textbf{Definition:} The weighted average value of a random variable $X$ is known as the expected value or expectation, written as $E(X)(E[X],\mathbb{E}(X), u, u_x)$<br><br><br>We focus on discrete r.v. first:<br><br>\begin{equation*}<br>E(X)=u=\sum_{x}^{\ } x\cdot P(X=x)<br>\end{equation*}<br><br>Another name: The \textbf{mean} of a discrete r.v.<br><br>Notation for the discrete r.v.:<br><br>\textbf{Example}<br><br>Let X denote the damage that a hit can do.<br><br>The event of a standard hit is $\{ X=100 \}$ with probability $P(X=100)$<br><br>\begin{equation*}<br>\begin{split}<br>E(X)&amp;=100\cdot P(X=100)+120\cdot P(X=120)+200\cdot P(X=200)+240\cdot P(X=240) \\<br>&amp;=100\cdot \frac{12}{20}+120\cdot \frac{3}{20}+200\cdot \frac{4}{20}+240\cdot \frac{1}{20} \\<br>&amp;=130 \\<br>\end{split}<br>\end{equation*}<br>[/latex]
The Variance and SD of a discrete r.v.	[latex]<br>\begin{itemize}<br>\item Variance notation: $Var(X),\mathbb(V)(X), \sigma^2\ or\ \sigma_x^2$<br>\item SD notation: $\sigma\ or\ \sigma_x$<br>\end{itemize}<br><br>\begin{equation*}<br>\begin{split}<br>Var(X)&amp;=\sigma^2=\sum_{x}^{\ }(x-u)^2\cdot P(X=x) \\<br>\sigma &amp;=\sqrt{\sum_{x}^{\ }(x-u)^2\cdot P(X=x)} \\<br>\end{split}<br>\end{equation*}<br><br>[/latex]
A function of a random variable	[latex]<br>Given a r.v. X with probability function $P(X=x)$, the expectation $E(X)$, and the variance $Var(X)$.<br><br>We want to find the expectation and variance of another r.v. based on the given one, where can be a real-valued function of X, denoted as g(X). Let a and c be constants.<br><br>pg. 11 for more<br>[/latex]
A linear combination of two r.v.s	[latex]<br>\begin{itemize}<br>\item If $X$ and $Y$ are r.v.s, and $a$ and $b$ are some fixed constants. A linear combination is given by:<br>$$<br>Z=aX+bY<br>$$<br><br>Then $E(Z)=aE(X)+bE(Y),\ Var(Z)=a^2Var(X)+b^2Var(Y)$<br><br>\item If $X$ and $Y$ are r.v.s, and $a,b,c$ are some fixed constants. A linear combination is given by:<br>$$<br>Z=aX+bY+c<br>$$<br><br>Then $E(Z)=?$, $Var(Z)=?$<br>\end{itemize}<br>[/latex]
Bernoulli distribution	[latex]<br>Flip a fair coin is often used as an example in stats.<br><br>This is a classic example of Bernoulli process.<br><br>\textbf{Bernoulli distribution: X~Ber(p)} where $p$ is the paramater<br><br>\textbf{Bernoulli trial:}<br>\begin{enumerate}<br>\item The process has exactly two outcomes: success(1), or failure (0).<br>\item The probability of success on a single trial is equal to $p$; the probability of failure on a single trial is equal to $q=1-p$.<br>\item The trials are independent.<br>\end{enumerate}<br>\textbf{Probability}<br><br>\begin{equation*}<br>P(X=x)=\left\{\begin{array}{ll}<br>p, &amp; x=1 \\<br>q=1-p, &amp; x=0 \\<br>\end{array}\right.<br>\end{equation*}<br><br>\textbf{Properties}<br>\[<br>E(X)=p<br>\]<br>\[<br>Var(X)=pq<br>\]<br><br>[/latex]
Binomial distribution	"[latex]<br><br>\textbf{Binomial distribution: X~B(n,p)}<br><br>\textbf{Binomial process:}<br>\begin{enumerate}<br>\item The process consists of a fixed number, \textbf{n}, of identical trials.<br>\item Each trial is a Bernoulli process.<br>\end{enumerate}<br><br>\textbf{A binomial r.v. X} is the number of successes that occur in \textbf{n} trials.<br><br>\textbf{Probability:}<br><br>\begin{equation*}<br>P(X=x)= \binom{n}{x} p^{x} q^{n-x} \qquad x=0,1,\ldots ,n,<br>\end{equation*}<br><br>where $q=1-p$, $\binom{n}{x}=\frac{n!}{x!(n-x)!}$ (read as ""n choose k"")<br><br>\textbf{Properties:}<br><br>\[<br>E(X)=np<br>\]<br>\[<br>Var(X)=npq<br>\]<br><br><br><br>[/latex]"
Relationship between Bernoulli and Binomial distribution	[latex]<br>Consider the relationship between Bernoulli distribution and binomial distribution. We can have the following statement:<br><br>If $X~B(n,p)$, and independent $Y_i ~ Ber(p)$, where $i=1,\cdots,n$, then $X=\sum_{i=1}^{n} Y_i$<br><br>Therefore<br><br>\begin{equation*}<br>\begin{split}<br>E(Y_i)&amp;=p, \quad Var(Y_i)=pq \\<br>E(X)&amp;=E(\sum_{i=1}^{n} Y_i)=\sum_{i=1}^{n} E(Y_i)=np \\<br>Var(X)=Var(\sum_{i=1}^{n} Y_i)=\sum_{i=1}^{n} Var(Y_i)=npq \\<br>\end{split}<br>\end{equation*}<br><br>[/latex]
Geometric distribution	[latex]<br>\textbf{Geometric distribution: X~Geom(p)}<br><br>\textbf{Geometric process:}<br><br>\begin{enumerate}<br>\item The process consists of identical and dependent trials.<br>\item Each trial is a Bernoulli process.&nbsp;<br>\end{enumerate}<br><br>\textbf{A geometric r.v.} \textbf{X} is the number of the trials in which the first success occurs.<br><br>\textbf{Probability:}<br><br>\begin{equation*}<br>P(X=x)=q^{x-1}p,\quad x=1,2,\ldots<br>\end{equation*}<br><br>\textbf{Properties:}<br><br>\[<br>E(X)=\frac{1}{p}<br>\]<br>\[<br>Var(X)=\frac{q}{p^2}<br>\]<br><br>[/latex]
Negative Binomial Distribution	[latex]<br>\textbf{Negative binomial distribution: X~NB(k,p)}<br><br>\textbf{A negative binomial r.v. X} is the number of identical and independent Bernoulli trials on which the k-th success occurs.<br><br>\textbf{Probability}<br><br>\[<br>P(X=x)=\binom{x-1}{k-1}p^k q^{x-k}, \quad x=k,k+1,\ldots<br>\]<br><br>where $\binom{x-1}{k-1}=\frac{(x-1)!}{(k-1)!(x-k)!}$<br><br>\textbf{Properties:}<br><br>\[<br>E(X)=\frac{k}{p}<br>\]<br><br>\[<br>Var(X)=\frac{kq}{p^2}<br>\]<br><br>[/latex]
Poisson distribution	[latex]<br>\textbf{Poisson distribution: X~Pois($\lambda$)}<br><br>\textbf{A Poisson r.v. X} is the number of successes that occur in a time period, if it occurs with average rate $\lambda$ (in that time period).<br><br>\textbf{Probability:}<br><br>\[<br>P(X=x)=\frac{e^{-\lambda}\cdot \lambda^x}{x!}, \quad x=0,1,2,\ldots<br>\]<br><br>\textbf{Properties:}<br><br>\[<br>E(X)=\lambda<br>\]<br>\[<br>Var(X)=\lambda<br>\]<br><br>The poisson distribution is a limiting case of the binomial distribution.<br><br><br><br>[/latex]
The boolean type and operators	<ul><li>Java provides six comparison operations(known as relational operators) that can be used to compared values, once this comparison is finished a boolean is returned.</li><li>e.g. boolean b = (1 &gt; 2);</li></ul>
if and if-else statements	<ul><li>Braces are optional for a single statement but it is usually best to use braces.</li></ul>
conditional operator	[latex]<br>(boolean-expression) ? expression1 : expression2;<br><br>would be the same as:<br><br>if (boolean-expression) {<br>expresison1;<br>} else {<br>expression2;<br>}<br><br>[/latex]
short-circuit operators	<ul><li>&amp;&amp; and || are short-circuit operators</li><li>e.g. p1 &amp;&amp; p2, if p1 is false, then (p1 &amp;&amp; p2) is false</li><li>e.g. p1 || p2, if p1 is true, then (p1 || p2) is true</li></ul>
Ending a loop with a sentinel value	<ul><li>You may use an input value to signify the end of the loop</li><li>Such a value is known as a sentinel value</li></ul>
for loops	<ul><li>The initial-action in a for loop can be a list of zero or more comma-separated expressions(before the boolean expression)</li><li>The action-after-each iteration in a for loop can be a list of zero or more comma-separated statements (after the boolean expression)</li></ul>
Loops and floating-point accuracy	<ul><li>Calculations involving floating-point numbers are approximated because these numbers are not stored with complete accuracy.</li><li>As such, do not use floating-point values for equality checking in a loop control.</li></ul>
infinite loops	<ul><li>if the loop-continuation-condition in a for loop is omitted, it is implicitly true</li></ul>
break in a loop	<ul><li>immediately terminate the loop</li></ul>
continue in a loop	<ul><li>end the current iteration--program control goes to the end of the loop body for the start of the next iteration</li></ul>
variable and method names	<ul><li>use camelCase</li></ul>
defining methods	<ul><li>a method is a collection of statements that are grouped together to perform an operation</li></ul>
method signature	<ul><li>the method signature is the combination of the method name and the parameter list</li></ul>
formal paramters	<ul><li>the variables defined in the method header</li></ul>
actual parameters	<ul><li>when a method is invoked, you pass a value to the paramater</li></ul>
pass by value	<ul><li>java uses <b>pass by value</b> to pass arguments to a method</li></ul>
return value type	<ul><li>the return value type is the data type of the value the method returns</li><li>if it doesn't return a value then the return value type is <b>void</b></li></ul>
instance methods vs static methods	<ul><li>instance methods can only be invoked from a specific instance of a class e.g. referenceVariable.methodName(arguments)</li><li>static methods can be invoked without using an object (i.e. they are not tied to a specific instance) e.g. ClassName.methodName(arguments)</li></ul>
overloading methods	<ul><li>overloading methods enable you to define the methods with the same name <b>as long as their parameter lists are different</b></li></ul>
ambiguous invocation	<ul><li>The java compiler determines which method to use based on the method signature</li><li>sometimes there may be two or more possible matches for an invocation of a method, but the compiler cannot determine the most specific match</li><li>this is referred to as ambiguous invocation</li><li>ambiguous invocation is a compile error</li></ul>
scope of local variables	<ul><li>the scope of a local variable starts from its declaration and continues to the end of the block that contains the variable.</li></ul>
stepwise refinement	"<ul><li>the concept of method abstration can be applied to the process of developing programs</li><li>when writing a large program, you can use the ""divide and conquer"" strategy, also known as <b>stepwise refinement</b>, to decompose it into subproblems</li><li>the subproblems can be further decomposed into smaller, more manageable problems.</li></ul>"
bottom-up implementation	<ul><li>bottom-up approach is to implement one method in the structure chart at a time from the bottom to the top</li><li>for each method implemented, write a test program to test it</li></ul>
top-down implementation	<ul><li>Top-down approach is to implement one method in the structure chart at a time from the top to the bottom</li><li><b>stubs</b> can be used for the methods waiting to be implemented<br>- a <b>stub</b> is a simple but incomplete version of a method<br>- the use of stubs enables you to test invoking the method from a caller</li></ul>
implementation	<ul><li>both top-down and bottom-up methods are fine</li><li>both approaches implement the methods incrementally and help to isolate programming errors and makes debugging easy.</li><li>sometimes they can be used together</li></ul>
Declaring array variables	<ul><li>datatype[] arrayRefVar;<br>- e.g. double[] myList;</li></ul>
creating arrays	<ul><li>arrayRefVar = new datatype[arraySize];</li></ul>
declaring and creating an array in one step	<ul><li>datatype[] arrayRefVar = new datatype[arraySize];</li></ul>
the length of an array	"<ul><li>once created, its size is fixed</li><li>find its size using <u style="""">arrayRefVar.length</u></li></ul>"
default values	<ul><li>when an array is created, its elements are assigned the default value of:</li><li>0 for the <u>numeric primitive data types</u></li><li>'\u0000' for <u>char type</u></li><li>false for <u>boolean type</u></li></ul>
indexed variables	<ul><li>each element in the array is represetned using the following syntax, known as an <b>indexed variable</b>.<br></li><li>arrayRefVar[index];</li></ul>
array initializers	<ul><li>declaring, creating and initializing in one step<br>e.g. double[] myList = {1.9, 2.9, 3.4, 3.5};</li><li>this shorthand syntax must be in one statement</li></ul>
For-each loops	<ul><li>traverse the complete array sequentially without using an index variable<br>e.g. for (elementType value : arrayRefVar) {}</li></ul>
copying arrays	<ul><li><b>The assignment statement does not copy the contents</b>, it only copies the <b>reference value</b>.</li><li>i.e. list2 = list1;</li><li>where list2 will have the reference values to the elements in list1</li><li>to copy the contents of one array to another, you must copy the array's individual elements to the other array, to do this use a <b>for loop</b> or the <b>System.arraycopy</b> method.<br>e.g. arraycopy(sourceArray, source_position, targetArray, target_position, length)</li></ul>
passing arrays to methods	<ul><li>when passing an array to a method, the <b>reference</b> of the array is passed to the method.</li></ul>
anonymous array	<ul><li>the statement printArray(new int[]{3,1,2,6,4,2}); creates an <b>anonymous array</b> inside the parameters of the method printArray.</li></ul>
pass by value - 2	<ul><li>for a parameter of a primitive type, the <b>actual value</b> is passed(we can change this value in the method but it will not change the value outside the method.)<br></li><li>for a parameter of an array type, the <b>reference value</b> is passed(changing the array in the method changes the array outside the method.)</li></ul>
heap	<ul><li>The JVM stores the array in an area of memory called the heap, which is used for dynamic memory allocation.</li></ul>
command-line parameters	<ul><li>In the main method, the arguments of the method correspond to the arguments in the command line when executing a program i.e. when we do java &lt;classFileName&gt; arg0 arg1 arg2 .....</li></ul>
Two dimensional arrays	<ul><li>dataType[][] refVar; //declaration, no reference to array so variable is null</li><li>refVar = new dataType[10][10]; // creation, assign reference to variable</li><li>dataType[][] refVar = new dataType[10][10]; // combine declaration and creation in one statement</li><li>you can also use an array initializer to declare, create and initialize a two-dimensional array.</li><li>a two-dimensional array is an <b>array of arrays</b>.</li></ul>
ragged arrays	<ul><li>each row in a two-dimensional array is itself an array</li><li>the rows can have different lengths</li><li>if so, then the array is called a <b>ragged array.</b></li></ul>
higher dimensional arrays	<ul><li>in java you can create n-dimensional arrays for any integer n</li></ul>
procedural programming	<ul><li>data and operations on data are separate</li><li>requires passing data to methods</li></ul>
OOP	<ul><li>data and operations on data are in an object</li><li>organizes programs like the real world</li><li>makes programs easier to both develop and maintain</li></ul>
Objects and classes	<ul><li>classes are constructs that define objects of the same type<br></li><li>objects represent an entity in the real world that can be distinctly identified</li></ul>
Objects	<ul><li>An object has a unique identity, state and behaviors</li><li>An object is a <b>unique isntance of a class</b></li><li>the <b>state</b> of an object consists of a <b>set of data fields</b> (also known as properties) with their current values.</li><li>the <b>behavior</b> of an object is defined by a <b>set of methods</b>.</li><li>The state defines the object<br></li><li>The behavior defines what the object does</li></ul>
Classes	<ul><li>A Java class uses <b>variables to define data fields</b> and <b>methods to define behaviors.</b></li><li>A class also provides special type of methods known as <b>constructors</b> which are invoked to construct objects from the class.</li></ul>
Constructors	<ul><li>Constructors must have the <b>same name</b> as the class itself</li><li>A constructor with no parameters is referred to as a <i>no-arg constructor</i></li><li>Constructors <b>do not have a return type</b></li><li>Constructors are invoked using the new operator when an object is created</li><li>Constructors play the role of initializing objects</li></ul>
default constructor	<ul><li>A class may be defined without constructors<br></li><li>In this case, a no-arg constructor with an empty body is <b>implicitly</b> defined in the class</li><li>this constructor, called a <b>default constructor</b>, is provided automatically <b>only if</b> no constructors are <b>explicitly</b> defined in the class.</li></ul>
object reference variables	<ul><li>To reference an object, assign the object to a reference variable</li><li>To declare a referene variable, use the syntax:<br>ClassName objectRefVar;<br></li><li>To declare and create in one step do:<br>ClassName objectRefVar = new ClassName();</li></ul>
accessing an objects members	"<ul><li>Use the object member access operator(the <b>dot operator</b> ""."")</li><li>Reference the objects data using:<br>objectRefVar.variableName</li><li>Invoke the object's method using:<br>objectRefVar.methodName(arguments)</li></ul>"
instance data fields and methods <b><i><u>vs</u></i></b> static data fields methods	<ul><li><b>Instance</b> data fields and methods can only be accessed using an object (i.e. an instance of a class)<br></li><li><b>Instance data field</b>:<br>objectRefVariable.variableName</li><li><b>Instance method</b>:<br>objectRefVariable.methodName(arguments)</li><li><b>Static</b> data fields and methods can be accessed without using an object.</li><li><b>Static data field:</b><br>className.variableName</li><li><b>Static method:</b><br>ClassName.methodName(arguments)</li></ul>
Reference data fields and null	"<ul><li>The data fields can be of reference types.</li><li>If a data field of a reference type does not reference any object, then the data field holds the special Java literal value <b style="""">null</b>.</li></ul>"
Default value for a data field	<ul><li>The default value of a data field is:</li><li><b>null</b> for a reference type</li><li><b>0</b> for a numeric type</li><li><b>false</b> for a boolean type</li><li><b>'\u0000'</b> for a char type</li></ul>
Default values for local variables	<ul><li>Note: Java assigns <b>no default value to a local variable</b> inside a method</li></ul>
Differences between variables of primitive data types and object types	<ul><li>A variable of a <b>primitive type</b> holds a value of the primitive type.</li><li>A variable of a <b>reference type</b> holds a reference to where an object is stored in memory.</li></ul>
Garbage and its collection	<ul><li>If an object is no longer referenced, then it is considered <b>garbage</b>.</li><li>Garbage occupies memory space.</li><li>Garbage collection<br>JVM automatically detects garbage and reclaims the space it occupies</li><li>You can assign an object null if it is no longer needed.</li></ul>
Instance variables <b>vs</b> static variables	<ul><li>An <b>instance</b> variable belongs to a specific instance of a class</li><li>A <b>static</b> variable is shared by all objects of the class</li></ul>
Static member	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item In code using a class, the best practice is to make invocations of static methods and access of static data fields \textbf{obvious}.<br>&nbsp;&nbsp;&nbsp; \item Use:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClassName.methodName(arguments)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClassName.variableName<br><br>&nbsp;&nbsp;&nbsp; \item Do not use:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objectRef.methodName(arguments)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; objectRef.variableName<br><br><br>\end{itemize}<br><br>[/latex]
Static modifier	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item To declare static variables, constants, and methods, use the \textbf{static} modifier<br><br>&nbsp;&nbsp;&nbsp; \item \textbf{static} is a Java keyword<br><br>\end{itemize}<br><br>[/latex]
Limitations of static methods	[latex]<br><br>\begin{itemize}<br><br>\item An \textbf{instance} method can<br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Invoke an \textbf{instance or static} method<br>&nbsp;&nbsp;&nbsp; \item Access an \textbf{instance or static} data field<br><br>\end{itemize}<br><br>\item A \textbf{static} method can<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Invoke a \textbf{static} method<br>&nbsp;&nbsp;&nbsp; \item Access a \textbf{static} data field<br><br>\end{itemize}<br><br>\item A static method \textbf{cannot}<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Invoke an \textbf{instance} method<br><br>&nbsp;&nbsp;&nbsp; \item Access an \textbf{instance} members<br><br>\end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Static methods	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item If a member method or data field is independent of any specific instance, then make it static<br><br>&nbsp;&nbsp;&nbsp; \item Do not require those using your class to create an instance unless it is absolutely necessary<br><br>\end{itemize}<br><br>[/latex]
Visibility modifiers	[latex]<br><br>\begin{itemize}<br><br>\item Visibility modifiers can be used to specify the visibility of a class and its members.<br><br>\item By \textbf{default}, the class, variable, or method can be accessed by any class \textbf{in the same package}<br><br>\item Packages can be used to organize classes<br><br>\item There is \textbf{no restriction} on accessing data fields and methods from \textbf{inside} the class.<br><br>\item A \textbf{visibility modifier} specifies how data fields and methods in a class can be accessed from \textbf{outside} the class.<br><br>\item public<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The class, data, or method is visible to \textbf{any class in any package}<br><br>\end{itemize}<br><br>\item private<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Modifier \textbf{cannot} be applied to a class, only its members<br><br>&nbsp;&nbsp;&nbsp; \item The data or methods can be accessed \textbf{only by the declaring class}.<br><br>\end{itemize}<br><br>\item protected<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Used in inheritance<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Packages and classes	[latex]<br><br>\begin{itemize}<br><br>\item The \textbf{default} modifier (i.e., no modifier) on a class restricts access to \textbf{within a package}<br><br>\item The \textbf{public} modifier enables \textbf{unrestricted} access<br><br>\end{itemize}<br><br>[/latex]
Packages, classes, and members	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The \textbf{private} modifier restricts access to \textbf{within a class}.<br>&nbsp;&nbsp;&nbsp; \item The \textbf{default} modifier (i.e., no modifier) restricts access to \textbf{within a package}.<br>&nbsp;&nbsp;&nbsp; \item The \textbf{public} modifier enables \textbf{unrestricted} access.<br><br>\end{itemize}<br><br>[/latex]
Visibility of own members	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item There is \textbf{no restriction} on accessing data fields and methods from \textbf{inside} the class.<br>&nbsp;&nbsp;&nbsp; \item However, an object cannot access its \textbf{private} members \textbf{outside} the class.<br><br>\end{itemize}<br><br>[/latex]
Constructors	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Use public constructors in most cases<br><br>&nbsp;&nbsp;&nbsp; \item Use a private constructor if you want to prohibit users from creating an instance of a class<br><br>\end{itemize}<br><br>[/latex]
Data field encapsulation	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item It is a best practice to \textbf{declare all data fields private}.<br><br>&nbsp;&nbsp;&nbsp; \item Protects data<br><br>&nbsp;&nbsp;&nbsp; \item Makes class easier to maintain<br><br>\end{itemize}<br><br>[/latex]
Accessor and mutator	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Accessor<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Provide a \textbf{getter} method to read a private data field<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Mutator<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Provide a \textbf{setter} method to modify a private data field<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Pass by value	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Remember, Java uses \textbf{pass by value} to pass arguments to a method<br><br>&nbsp;&nbsp;&nbsp; \item For a parameter of a \textbf{primitve type}, the \textbf{actual value} is passed<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Changing the value of the local parameter inside the method \textbf{does not affect} the value of the variable outside the method.<br><br>\end{itemize}<br><br>\item For a paramater of an \textbf{array or object type}, the \textbf{reference value} is passed<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Any changes to the array that occur inside the method body \textbf{will affect} the original array or object that was passed as the argument.<br><br>\end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Arrays of objects	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item An array can hold objects as well as primitive type values<br><br>&nbsp;&nbsp;&nbsp; \item An array of objects is actually an array of reference variables<br><br>&nbsp;&nbsp;&nbsp; \item Create an array \textbf{and} each object in it<br><br>&nbsp;&nbsp;&nbsp; \item When creating an array using new, each element in the array is a reference variable with a default value of \textit{null}.<br><br>\end{itemize}<br><br>[/latex]
Immutable objects and classes	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Occasionally, it is desirable to create an object whose contents cannot be changed once the object has been created.<br><br>&nbsp;&nbsp;&nbsp; \item Such an object is called an \textbf{immutable object} and its class is called an \textbf{immutable class}.<br><br>&nbsp;&nbsp;&nbsp; \item e.g. if all the data fields are private, and we have no mutators in the class, then this \textit{could} make it an immutable class.<br><br>\end{itemize}<br><br>[/latex]
Immutable class	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Requirements of an immutable class<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item \textbf{All data fields} must be \textbf{private}.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item There \textbf{cannot be any mutator methods} for data fields<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item \textbf{No accessor methods can return} a reference to a data field that is \textbf{mutable}.<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Scope of variables revisited	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The scope of \textbf{class variables} (instance and static data fields) is the entire class.<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item They can be declared anywhere inside a class<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item They have default values<br><br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The scope of a \textbf{local variable} starts from its declaration and continues to the end of the block that contains the variable.<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Java assigns no default value to a local variable inside a method.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item A local variable must be initialized explicitly before it can be used<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item If a local variable has the same name as a class variable, then \textbf{the local variable takes precedence} (i.e. the class variable is hidden)<br><br>\end{itemize}<br><br>[/latex]
this reference	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The \textit{This} keyword is the name of a reference that refers to an object itself<br><br>&nbsp;&nbsp;&nbsp; \item One common use of the \textit{this} keyword is to reference a hidden class variable.<br><br>&nbsp; &nbsp; &nbsp;\item It can also be used \textbf{inside a constructor} to invoke another constructor of the same class.<br><br>\end{itemize}<br><br>[/latex]
Use this to reference data fiields	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item For a hidden \textbf{static variable}, use ClassName.staticVariable<br><br>&nbsp;&nbsp;&nbsp; \item Best practice is to \textbf{use the data field name as the parameter name in the setter method or a constructor}<br><br>\end{itemize}<br><br>[/latex]
Procedural programming: method abstraction	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item You can think of the method body as a black box that contains the detailed implementation for the method.<br><br>\end{itemize}<br><br>[/latex]
Object-oriented programming: class abstraction and encapsulation	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Class abstraction means to separate class implementation from the use of the class.<br><br>&nbsp;&nbsp;&nbsp; \item The creator of the class provides a description of the class and lets the user know how the class scan be used.<br><br>&nbsp;&nbsp;&nbsp; \item The user of the class does not need to know how the class is implemented.<br><br>&nbsp;&nbsp;&nbsp; \item The detail of implementation is encapsulated and hidden from the user.<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Class encapsulation<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item A class is called an \textbf{abstract data type(ADT)}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A class is designed for use by many different users (or customers or clients)<br><br>&nbsp;&nbsp;&nbsp; \item To be useful in a wide range of applications, a class should provide a variety of ways for customization through properties, and cosntructors and methods that together are \textbf{minimal and complete}.<br><br>\end{itemize}<br><br>[/latex]
Class relationships	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item To design classes, one must understand the relationships among classes:<br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Association<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Aggregation<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Composition<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Inheritance<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Association	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A general binary relationship that describes an activity between two classes<br><br>&nbsp;&nbsp;&nbsp; \item Multiplicity<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item The number of objects of a class<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item In Java, associations can be implemented using data fields and methods, e.g.:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item A student takes a course (then we add an addCourse method in Student class and addStudent method in Course class)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Aggregation	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A special form of association representing an owner-subject relationship<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item The \textit{owner} object is called an \textbf{aggregating} object and its class is called an \textbf{aggregating class}.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item The \textit{subject} object is called an \textbf{aggregated} object and its class is called an \textbf{aggregated class}.<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Models \textbf{has-a} relationships, e.g.:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item A student \textbf{has-a} name<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item A student \textbf{has-an} address<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Composition	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Aggregation between objects is called \textbf{composition} if the existence of the aggregated object is dependent on the aggregating object<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Exclusive ownership of the subject<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item The subject (i.e., aggregated object) cannot (conceptually) exist on its own.<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Aggregation and composition	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Usually represented as a data field in the aggregating class.<br><br>\end{itemize}<br><br>[/latex]
Aggregation between same class	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Aggregation may exist between objects of the same class<br><br>\end{itemize}<br><br>[/latex]
Aggregation or composition	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Warning: Since aggregation and composition relationships are represented using classes in similar ways, many texts do not differentiate them, calling both compositions.<br><br>\end{itemize}<br><br>[/latex]
Class design and development	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Warning: Since aggregation and composition relationships are represented using classes in similar ways, many texts do not differentiate them, calling both compositions.<br><br>\end{itemize}<br><br>[/latex]
Object-oriented thinking	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Classes provide more flexibility and modularity for building reusable software<br><br>&nbsp;&nbsp;&nbsp; \item Class abstraction and encapsulation<br><br>\end{itemize}<br><br>[/latex]
Primitive data type values as objects	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A primitive data type is not an object<br><br>&nbsp;&nbsp;&nbsp; \item But it can be wrapped in an object using a Java API wrapper class<br><br>&nbsp;&nbsp;&nbsp; \item Notes:<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item The wrapper classes do not have \textbf{no-arg constructors}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item The instances of all wrapper classes are \textbf{immutable} (i.e. their internal values cannot be changed once the objects are created)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
wrapper classes	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Constructors<br><br>&nbsp;&nbsp;&nbsp; \item Class constants MAX_VALUE and MIN_VALUE<br><br>&nbsp;&nbsp;&nbsp; \item Conversion methods<br><br>\end{itemize}<br><br>[/latex]
Numeric wrapper class constructors	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item You can construct a wrapper object either from a primitive data type value or from a string representing the numeric value<br><br>\end{itemize}<br><br>[/latex]
Numeric wrapper class constants	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Each numerical wrapper class has the constants MAX_VALUE and MIN_VALUE<br><br>&nbsp;&nbsp;&nbsp; \item MAX_VALUE represents the maximum value of the corresponding primitive data type<br><br>&nbsp;&nbsp;&nbsp; \item For Byte, Short, Integer, and Long, MIN_VALUE represents the minimum byte, short, int, and long values.<br><br>&nbsp;&nbsp;&nbsp; \item For Float and Double, MIN_VALUE represents the minimum \textbf{positive} float and double values.<br><br>\end{itemize}<br><br>[/latex]
Numeric wrapper class conversion methods	"[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Each numeric wrapper class implements the abstract methods:<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item doubleValue<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item floatValue<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item intValue<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item longValue<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item shortValue<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item These methods ""convert"" objects into primitive types values.<br><br>\end{itemize}<br><br>[/latex]"
Numeric wrapper class static valueOf methods	"[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The numeric wrapper classes have a useful class method valueOf(String s)<br><br>&nbsp;&nbsp;&nbsp; \item This method creates a new object initialized to the value represented by the specified string<br><br>&nbsp;&nbsp;&nbsp; \item e.g.:<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Double doubleObject = Double.valueOf(""12.4"")<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]"
Numeric wrapper class static parsing methods	"[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Each numeric wrapper class has two overloaded parsing methods to parse a numeric string into an appropriate numeric based on 10 or any specified radix (e.g. 2 for binary, 8 for octal, 10 for decimal, 16 for hexadecimal)<br><br>&nbsp;&nbsp;&nbsp; \item For example:<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Integer.parseInt(""13"") returns 13<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Integer.parseInt(""13"", 10) returns 13<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Integer.parseInt(""1A"", 16) returns 26<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]"
Automatic conversion between primitive types and wrapper class types	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Converting a primitive value to a wrapper object is called \textbf{boxing}.<br><br>&nbsp;&nbsp;&nbsp; \item Converting a wrapper object to a primitive value is called \textbf{unboxing}.<br><br>&nbsp;&nbsp;&nbsp; \item The Java compiler will automatically convert a primitive data type value to an object using a wrapper class(\textbf{autoboxing}) and vice versa (\textbf{autounboxing}), depending on the context.<br><br>\end{itemize}<br><br>[/latex]
BigInteger and BigDecimal classes	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item If you need to compute with very large integers or high precision floating-poiunt values, you can use the BigInteger and BigDecimal classes in the java.math package<br><br>&nbsp;&nbsp;&nbsp; \item Both are \textbf{immutable}<br><br>&nbsp;&nbsp;&nbsp; \item Both extend the Number class and implement the Comparable interface<br>&nbsp;&nbsp;&nbsp; <br>\end{itemize}<br><br>[/latex]
String class	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The String class has 13 constructors and more than 40 methods<br><br>&nbsp;&nbsp;&nbsp; \item A good example for learning classes and objects<br>&nbsp;&nbsp;&nbsp; <br>\end{itemize}<br><br>[/latex]
Constructing strings	"j[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Create from a string literal<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Syntax<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item String newString = new String(stringLiteral);<br><br>\end{itemize}<br><br>\item Since strings are used frequently, Java provides a shorthand initializer for creating a string e.g.:<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item String message = ""Welcome to Java"";<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>\item Create from an array of characters<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Syntax:<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item String newString = new String(charArray);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br>&nbsp;&nbsp;&nbsp; <br>\end{itemize}<br><br>[/latex]"
Strings are immutable	"[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A String object is immutable (i.e. its contents cannot be changed once the string is created)<br><br>&nbsp;&nbsp;&nbsp; \item The following code does not change the contents of the string:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String s = ""Java"";<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s = ""HTML"";<br><br>&nbsp;&nbsp;&nbsp; \item Instead what happens is that a new string object is created and s will now reference the string object with the value ""HTML""<br>&nbsp;&nbsp;&nbsp; <br><br>\end{itemize}<br><br>[/latex]"
Interned strings	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Since strings are immutable and are frequently used, to improve efficiency and save memory, the JVM uses a unique instance for string literals with the same character sequence<br><br>&nbsp;&nbsp;&nbsp; \item Such an instance is called \textbf{interned}<br><br>&nbsp;&nbsp;&nbsp; \item A new object is created if you use the new operator<br><br>&nbsp;&nbsp;&nbsp; \item If you use the string initalizer, no new object is created if the interned object is already created i.e. two variables initialized with the same string literal(same characters) will be pointing to the same String object.<br><br>\end{itemize}<br><br>[/latex]
Replacing and splitting strings	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item stringLiteral.replace(charInLiteral, char)<br>&nbsp;&nbsp;&nbsp; \item stringLiteral.replaceFirst(charInLiteral, char)<br>&nbsp;&nbsp;&nbsp; \item stringLiteral.replace(charInLiteral, stringLiteral)<br>&nbsp;&nbsp;&nbsp; \item stringLiteral.replace(stringLiteral, stringLiteral)<br><br>&nbsp;&nbsp;&nbsp; \item Split a string into an array of strings<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item String[] tokens = stringLiteral.split(charDelimiter, 0);<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Matching, replacing, and splitting by patterns	"[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item You can match, replace, or split a string by specifying a pattern<br><br>&nbsp;&nbsp;&nbsp; \item Example:<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item ""Java"".equals(""Java"");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item ""Java"".matches(""Java"");<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item This is an extremely useful and powerful feature known as \textbf{regular expression (regex)}<br><br>\end{itemize}<br><br>[/latex]"
Convert character and numbers to strings	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The String class provides several static valueOf methods for converting a character, an array of characters, and numeric values to strings<br><br>&nbsp;&nbsp;&nbsp; \item These methods have the same name valueOf with different argument types char, char[], double, long, int, and float<br><br>&nbsp;&nbsp;&nbsp; \item For example<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item String.valueOf(5.44)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item This return value string consists of characters '5', '.', '4', '4'.<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
StringBuilder and StringBuffer classes	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The StringBuilder and StringBuffer classes are alternatives to the String class<br><br>&nbsp;&nbsp;&nbsp; \item In general, a StringBuilder or StringBuffer can be used wherever a string is used<br><br>&nbsp;&nbsp;&nbsp; \item StringBuilder and StringBuffer are more flexible than String<br><br>&nbsp;&nbsp;&nbsp; \item You can add, insert, or append new contents into a string buffer, whereas the value of a String object is fixed once the string is created<br><br>\end{itemize}<br><br>[/latex]
Inheritance	[latex]<br><br>\begin{itemize}<br><br>\item Suppose you define classes to model circles, rectangles, and triangles.<br><br>\item These classes have many common features<br><br>\item What is the best way to design these classes to avoid redundancy?<br><br>\item OOP allows you to define new classes from existing classes<br><br>\item This is called \textbf{inheritance}<br><br>&nbsp; &nbsp;\item The keyword \textbf{extends} tells the compiler that the (sub)class extends another (super)class<br><br>&nbsp;&nbsp;&nbsp; \item A Java class may inherit directly from only one superclass<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item This restriction is known as \textbf{single inheritance}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Some other programming languages allow classes to inherit from one or more classes which is known as \textbf{multiple inheritance}<br><br>\end{itemize}<br><br>[/latex]
Superclasses and subclasses	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Inheritance enables you to define a general class (i.e. a superclass) and later extend it to more specialized classes (i.e. subclasses)<br><br>&nbsp;&nbsp;&nbsp; \item A subclass inherits from a superclass<br><br>&nbsp;&nbsp;&nbsp; \item Models \textbf{is-a} relationships<br><br>&nbsp;&nbsp;&nbsp; \item A subclass \textbf{inherits} accessible data fields and methods from its superclass and may also add \textbf{new} data fields and methods<br><br>&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item \textbf{A subclass is not a subset of its superclass}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item A subclass usually contains \textbf{more} information and methods than its superclass<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br>&nbsp;&nbsp; <br>&nbsp;&nbsp; \end{itemize} <br><br>&nbsp;&nbsp;&nbsp; \item For example:<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item A rectangle has a width and height<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item A circle has a radius<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Both have a color<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A \textbf{superclass} is also called a \textbf{parent} class or \textbf{base} class<br><br>&nbsp;&nbsp;&nbsp; \item A \textbf{subclass} is also called a \textbf{child} class, \textbf{extended} class, or \textbf{derived} class.<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item A child class inherits from a parent class<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item A subclass extends a superclass<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item A derived class derives from a base class<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Remember, a class defines a type<br><br>&nbsp;&nbsp;&nbsp; \item A type defined by a subclass is called a \textbf{subtype}, and a type defined by its superclass is called a \textbf{supertype}<br><br>\end{itemize}<br><br>[/latex]
extends	&nbsp; &nbsp; \item The keyword \textbf{extends} tells the compiler that the (sub)class extends another (super)class<br><br>&nbsp;&nbsp;&nbsp; \item A Java class may inherit directly from only one superclass<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item This restriction is known as \textbf{single inheritance}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Some other programming languages allow classes to inherit from one or more classes which is known as \textbf{multiple inheritance}
Unified Modeling Language (UML)	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item + signifies public<br><br>&nbsp;&nbsp;&nbsp; \item - signifies private<br><br>&nbsp;&nbsp;&nbsp; \item Static variables and methods are \underline{underlined}<br><br>&nbsp;&nbsp;&nbsp; \item Open or no arrow is assocation<br><br>&nbsp;&nbsp;&nbsp; \item Hollow diamond is aggregation<br><br>&nbsp;&nbsp;&nbsp; \item Filled diamond is composition<br><br>&nbsp;&nbsp;&nbsp; \item Hollow triangle is inheritance<br><br>\end{itemize}<br><br>[/latex]
Methods and data fields visibility	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Private members cannot be accessed outside of a class, including one of of its subclasses<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Use accessor(getter) and mutator(setter) methods<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Superclass constructors and the super keyword	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Remember, a constructor is used to construct an instance of a class<br><br>&nbsp;&nbsp;&nbsp; \item Unlike properties and methods, \textbf{a superclass's constructors are not inherites in the subclass}<br><br>&nbsp;&nbsp;&nbsp; \item They can only be invoked from the subclass's constructors, using the keyword \textbf{super}<br><br>&nbsp;&nbsp;&nbsp; \item If the keyword super is not explicitly used, the superclass's no-arg constructor is automatically invoked.<br><br>&nbsp;&nbsp;&nbsp; \item Invoking the superclass constructor using super must be the first statement in the subclass's constructor<br><br>\end{itemize}<br><br>[/latex]
Constructor chaining	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Constructing an instance of a class invokes all the superclasses' constructors along the inheritance chain.<br><br>&nbsp;&nbsp;&nbsp; \item This is known as \textbf{constructor chaining}<br><br>\end{itemize}<br><br>[/latex]
Default constructor	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Remember, a class may be defined without constructors<br><br>&nbsp;&nbsp;&nbsp; \item In this&nbsp; case, a no-arg constructor with an empty body is \textbf{implicitly} defined in the class<br><br>&nbsp;&nbsp;&nbsp; \item This constructor, called a \textbf{default constructor}, is provided automatically only if no constructors are explicitly defined in the class.<br><br>&nbsp;&nbsp;&nbsp; \item Best practice is to provide (if possible) a no-arg constructor for every class to make the class easy to extend and avoid compile-time errors \textbf{during constructor chaining}<br><br>\end{itemize}<br><br>[/latex]
Defining a subclass	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A subclass inherits from a superclass<br><br>&nbsp;&nbsp;&nbsp; \item You can also<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Add new properties<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Add new methods<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Override the methods of the superclass<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Override the methods of the superclass	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A subclass inherits methods from a superclass<br><br>&nbsp;&nbsp;&nbsp; \item Sometimes it is necessary for the subclass to modify the implementation of a method defined in the superclass<br><br>&nbsp;&nbsp;&nbsp; \item This is referred to as \textbf{method overriding}<br><br>&nbsp;&nbsp;&nbsp; \item To override a method, the method must be defined in the subclass using \textbf{the same signature} as in its superclass, and \textbf{same or subtype of the overridden method's return type}.<br><br>&nbsp;&nbsp;&nbsp; \item A best practice is to avoid mistakes is to use a special Java syntax, called \textbf{override annotation}<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Annotated method is required to override a method in its superclass (otherwise there will be a \textbf{compile-time error})<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Put \textbf{@Override} before the method being overridden.<br><br>\end{itemize}<br><br>[/latex]
Overriding vs overloading	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item \textbf{Overridden methods}<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Have the&nbsp; same signature<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Are in different classes related by inheritance<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item \textbf{Overloaded methods}<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Have the same name, but different parameter lists<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Can be either<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item In the same class<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item In different classes related by inheritance<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Private methods of the superclass	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item An instance method can be overridden only if it is accessible<br><br>&nbsp;&nbsp;&nbsp; \item As such, \textbf{a private method cannot be overridden} because it is not accessible outside its own class<br><br>&nbsp;&nbsp;&nbsp; \item \textbf{If a method defined in a subclass is private in its superclass, then the two methods are completely unrelated}<br><br>\end{itemize}<br><br>[/latex]
Static methods of the superclass	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Like an instance method, a static method can be inherited<br><br>&nbsp;&nbsp;&nbsp; \item However, \textbf{a static method cannot be overridden}<br><br>&nbsp;&nbsp;&nbsp; \item \textbf{If a static method defined in the superclass is redfined in a subclass, the method defined in the superclass is hidden}<br><br>\end{itemize}<br><br>[/latex]
this and super keywords	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Similar to using \textbf{this} to reference the calling object, the keyword \textbf{super} refers to the superclass of the class which super appears<br><br>&nbsp;&nbsp;&nbsp; \item The keyword \textbf{this} is the name of a reference that refers to an object itself<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item One common use of the \textbf{this} keyword is to reference a hidden class member.<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The keyword \textbf{super} refers to the superclass of the class in which \textbf{super} appears<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item One common use of the super keyword is to reference a hidden \textbf{superclass} member.<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
super keyword	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Similar to using \textbf{this} to reference the calling object, the keyword \textbf{super} refers to the superclass of the class which super appears<br><br>&nbsp;&nbsp;&nbsp; \item The keyword \textbf{this} is the name of a reference that refers to an object itself<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item One common use of the \textbf{this} keyword is to reference a hidden class member.<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The keyword \textbf{super} refers to the superclass of the class in which \textbf{super} appears<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item One common use of the super keyword is to reference a hidden \textbf{superclass} member.<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
The Object class and its methods	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Every class in Java is descended from the java.lang.Object class<br><br>&nbsp;&nbsp;&nbsp; \item If no inheritance is specified when a class is defined, the superclass of the class is \textbf{Object}<br><br>\end{itemize}<br><br>[/latex]
The toString() method in Object	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The toString() method returns a string representation of the object<br><br>&nbsp;&nbsp;&nbsp; \item The default implementation returns a string consisting of a class name of which the object is an instance, the at sign (@), and a number representing this object<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \item The default implementation is not helpful, therefore it is best to override it in the user-defined class so that it returns a digestible string representation of the object.<br><br>\end{itemize}<br><br>[/latex]
Polymorphism	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Remember, a class defines a type<br><br>&nbsp;&nbsp;&nbsp; \item A type defined by a subclass is called a \textbf{subtype}, and a type defined by its superclass is called a \textbf{supertype}<br><br>&nbsp;&nbsp;&nbsp; \item \textbf{Polymorphism} means that a variable of a supertype can refer to a subtype object<br><br>&nbsp;&nbsp;&nbsp; \item An object of a \textbf{subtype} can be used wherever its \textbf{supertype} value is required<br><br>\end{itemize}<br><br>[/latex]
Declared type and actual type	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The type that declares a variable is called the variable's \textbf{declared type}<br><br>&nbsp;&nbsp;&nbsp; \item The actual class for the object referenced by the variable is called the \textbf{actual type} of the variable.<br><br>&nbsp;&nbsp;&nbsp; \item Remember, a variable of a reference type can hold a \textbf{null} value or a reference to an instance of the declared type.<br><br>\end{itemize}<br><br>[/latex]
Dynamic binding	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item If we have an object x, and its declared type is Object in a methods parameters, but the actual type passed into the method is instead a subtype of Object then if we have an implementation of toString(), each type passed into the method is going to have its own version of toString() by overriding.<br><br>&nbsp;&nbsp;&nbsp; \item Therefore, which implementation is used will be determined dynamically by the JVM \textbf{runtime}<br><br>&nbsp;&nbsp;&nbsp; \item This capability is known as \textbf{dynamic binding}<br><br>&nbsp;&nbsp;&nbsp; \item More generally suppose an object o is an instance of classes $C_{1}$, $C_{2}$, $\ldots $, $C_{n-1}$ and $C_{n}$ where $C_{1}$ is a subclass of $C_{2}$, $C_{2}$ is a subclass of $C_{3}$, $\ldots $, and $C_{n-1}$ is a subclass of $C_{n}$.<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item That is, $C_{n}$ is the most general class, and $C_{1}$ is the most specific class<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item In Java, $C_{n}$ is the Object class<br><br>&nbsp;&nbsp;&nbsp; If object o invokes a method p, the JVM searches the implementation for the method p in $C_{1}$, $C_{2}$, $\ldots $, $C_{n-1}$ and $C_{n}$, \textbf{specifically in this order}, until it is found.<br><br>&nbsp;&nbsp;&nbsp; \item Once an implementation is found, the search stops and the first-found implementation is invoked.<br><br>\end{itemize}<br><br>[/latex]
Matching and binding	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item \textbf{Matching} a method signature<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item The \textbf{declared type} of the reference variable decides which method to match at compile time.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item \textbf{Binding} a method implementation<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item A method may be implemented in several classes along the inheritance chain<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item The \textbf{actual type} of the reference variables decides which implementation of the method the JVM dynamically binds at runtime<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Casting objects	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item You have been using the casting operator to convert variables of one primitive type to another<br><br>&nbsp;&nbsp;&nbsp; \item Casting can also be used to convert an object of one class type to another within an inheritance hierarchy<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item This is called \textbf{casting object}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Upcasting is implicit	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The statement<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m(new Student());<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is equivalent to<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object o = new Student();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m(o);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; which is \textbf{implicit casting}<br><br>&nbsp;&nbsp;&nbsp; \item It is always possible to cast an instance of a subclass to a variable of a superclass<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item This is called \textbf{upcasting}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Downcasting	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Warning: explicit downcasting from a superclass to a subclass is usually not the way to go about things.<br><br>&nbsp;&nbsp;&nbsp; \item Override methods in subclasses instead<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \item Downcasting is such a bad practice that explicit casting must be used to confirm your intention to the compiler<br><br>&nbsp;&nbsp;&nbsp; \item For example<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Object o = new Student();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item m(o);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Student b = o; // Compile error<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Student c = (Student)o; // no error \textbf{ - Explicit Casting}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item If you are downcasting a superclass object to an object that is not an instance of a subclass, then a runtime exception occurs<br><br>&nbsp;&nbsp;&nbsp; \item Use the \textbf{instanceOf} operator to avoid this<br><br>\end{itemize}<br><br>[/latex]
Override equals method in Object	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Remember, usually a class should override the toString method so it returns a digestible string representation of the Object<br><br>&nbsp;&nbsp;&nbsp; \item You may also want to override the equals method<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item One of the few reasonable times to use downcasting<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Subclass and visibility/accessibility	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item If desired, a subclass \textbf{can increase accessibility} of a method defeined in the superclass, but a subclass \textbf{cannot decrease accessibility} of a method defined in the superclass.<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item For example, a subclass may override a protected method in its superclass and change its visibility to public<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item For example, if a method is defined as public in the superclass, it must be defined as public in the subclass <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Preventing extending and overriding	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item You may occasionally want to prevent classes from being extended<br><br>&nbsp;&nbsp;&nbsp; \item In such cases, use the \textbf{final} modifier to indicate a class is final and cannot be a parent class<br><br>\end{itemize}<br><br>[/latex]
The final modifier	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A final class cannot be extended<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item For example<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; final class Math \{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A final method cannot be overridden by its subclasses<br><br>&nbsp;&nbsp;&nbsp; \item And remember, a final variable is a constant<br><br>&nbsp;&nbsp;&nbsp; \item Modifiers are used on classes and class members (data and methods), except the final modifier can also be used on local variables in a method<br><br>&nbsp;&nbsp;&nbsp; \item A final local variable is a constant inside a method<br><br>&nbsp;&nbsp;&nbsp; \item A best practice is to use final variables liberally <br><br>\end{itemize}<br><br>[/latex]
Modifiers	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Access modifiers<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item For classes<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item public<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item default (no modifier)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item For methods<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item public<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item protected<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item default (no modifier)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item private<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Non-access modifiers<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item For classes<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item final<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item abstract<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item For methods (excluding constructors)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item final<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item static<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item abstract<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item For data fields<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item final<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item static<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
The ArrayList class	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item You can create an array to store objects, but the array's size is fized once the array is created<br><br>&nbsp;&nbsp;&nbsp; \item Java provides the \textbf{ArrayList} class that can be used to \textbf{store an unlimited number} of objects.<br><br>&nbsp;&nbsp;&nbsp; \item ArrayList is known as a generic class with a generic type E<br><br>&nbsp;&nbsp;&nbsp; \item You can specify a concrete type to replace E when creating an ArrayList<br><br>\end{itemize}<br><br>[/latex]
Exceptions	[latex]<br><br>\begin{itemize}<br><br>\item Exceptions are runtime errors caused by your program and external circumstances<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item These errors can be caught and handled by your program<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item First approach: <br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Mitigate exception with if statement<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Create a method, so we can resuse it<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Second approach:<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Have the method notify the caller<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Exception handling	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Exception handling enables a method to throw an exception to its caller<br><br>&nbsp;&nbsp;&nbsp; \item Without this capability, a method must handle the exception or terminate the program.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \item Separates<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item THe detection of an error<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item The handling of an error<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Exception types	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Exceptions are objects<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Remember, objects are instances of classes<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The root class for exception is Java.lang.Throwable<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Three major types:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item System errors<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Exceptions<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Runtime exceptions<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item System errors are thrown by the JVM and represented in the Error class.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Exception describes errors caused by your program and external circumstances.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item RuntimeException is caused by programming errors, such as bad casting, accessing out of bounds array, and numeric errors.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item All Java exception classes inherit directly or indirectly from Throwable<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Use overridden getMessage() member method<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item You can create your own exception classes by extending \textbf{Exception} or a subclass of \textbf{Exception}.<br><br>\end{itemize}<br><br>[/latex]
Unchecked Exceptions vs. Checked Exceptions	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Exceptions are objects<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Remember, objects are instances of classes<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The root class for exception is Java.lang.Throwable<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Three major types:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item System errors<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Exceptions<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Runtime exceptions<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item System errors are thrown by the JVM and represented in the Error class.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Exception describes errors caused by your program and external circumstances.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item RuntimeException is caused by programming errors, such as bad casting, accessing out of bounds array, and numeric errors.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item All Java exception classes inherit directly or indirectly from Throwable<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Use overridden getMessage() member method<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item You can create your own exception classes by extending \textbf{Exception} or a subclass of \textbf{Exception}.<br><br>\end{itemize}<br><br>[/latex]
Declaring exceptions	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Every method must state the types of \textbf{checked excpetions} it might throw<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item This is called \textbf{declaring exceptions}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Examples:<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item public void myMethod() throws IOException<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item public void myMethod() throws IOException, OtherException<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Throwing exceptions	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item When the program detects an error, the program can create an instance of an appropriate exception type and throw it.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item This is called \textbf{throwing an exception}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Catching exceptions	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item When an exception is thrown, it can be caught and handled in a \textbf{try-catch block}.<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item If no exceptions are thrown in the try block, then the catch blocks are skipped<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item If an exception is thrown in the try block, Java \textbf{skips the remaining statements in the try block} and starts the process of finding the code to handle the exception.<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item This is called \textbf{catching an exception}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The order exceptions are specified is important, a compile error occurs if a catch block for a superclass type appears before a catch block for a subclass type.<br><br>&nbsp;&nbsp;&nbsp; \item The code handling the exception is called the \textbf{exception handler}<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item It is found by \textbf{propagating} the exception backward through the call stacks, starting from the current method.<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Checked exceptions	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Remember, the compiler forces the programmer to check and deal with checked exceptions(i.e. any exception other than Error or RuntimeException)<br><br>&nbsp;&nbsp;&nbsp; \item If a method declares a checked exception, you \textbf{must} invoke it in a try-catch block or declare to throw the exception in the calling method.<br><br>\end{itemize}<br><br>[/latex]
The finally clause	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The \textbf{finally} clause is always executed, regardless of whether an exception occurred.<br><br>&nbsp;&nbsp;&nbsp; \item This is put after the catch block<br><br>\end{itemize}<br><br>[/latex]
Rethrowing exceptions	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Java allows an exception handler to rethrow the exception if the handler cannot process the exception (or simply wants to let its called be notified of the exception)<br><br>\item You can also throw a new exception along with the original exception<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item This is called \textbf{chained exception}<br><br>\end{itemize}<br><br>\end{itemize}<br><br><br><br>[/latex]
When to use a try-catch block	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Use a try-catch block to deal with \textbf{unexpected} error conditions<br><br>&nbsp;&nbsp;&nbsp; \item Do not use it to deal with simple, \textbf{expected} situations<br><br>\end{itemize}<br><br>[/latex]
When to throw exceptions	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Remember, an exception occurs in a method<br><br>&nbsp;&nbsp;&nbsp; \item If you want the exception to be processed by its caller, then you should create an exception object and throw it.<br><br>&nbsp;&nbsp;&nbsp; \item If you can handle the exception in the method where it occurs, then there is no need to throw it.<br><br>\end{itemize}<br><br>[/latex]
Defining custom exception classes	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Use the exception classes in the Java API whenever possible<br><br>&nbsp;&nbsp;&nbsp; \item If the predefined classes are insufficient, then you can define a custom exception class by extending the \textbf{java.lang.Exception} class.<br><br>\end{itemize}<br><br>[/latex]
"Exception handling #2"	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Exception handling separates error-handling code from normal programming tasks<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Makes programs easier to read and to modify<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The \textbf{try} block contains the code that is executed in \textbf{exceptional} circumstances<br><br>&nbsp;&nbsp;&nbsp; \item A method should \textbf{throw} an exception if the error needs to be handled by its caller<br><br>&nbsp;&nbsp;&nbsp; \item Warning: exception handling usually requires more time and resources because it requires instantiating a new exception object, rolling back the call stack, and propagating the errors to the calling methods.<br><br>\end{itemize}<br><br>[/latex]
Assertions	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item An \textbf{assertion} is a Java statement that enables you to assert an assumption about your program<br><br>&nbsp;&nbsp;&nbsp; \item An assertion contains a Boolean expression that should be true during program execution<br><br>&nbsp;&nbsp;&nbsp; \item Assertions can be used to assure program correctness and avoid logic errors<br><br>\end{itemize}<br><br>[/latex]
Declaring assertions	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item An assertion is declared using the Java keyword \textbf{assert} e.g.:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert assertion;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert assertion : detailMessage;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where assertion is a \textbf{Boolean expression} and detailMessage is a primitive-type or an Object value.<br><br>\end{itemize}<br><br>[/latex]
Executing assertions	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item When an assertion statement is executed, Java evaluates the assertion.<br><br>&nbsp;&nbsp;&nbsp; \item If it is false, an \textbf{AssertionError} will be thrown.<br><br>&nbsp;&nbsp;&nbsp; \item The \textbf{AssertionError} class has a no-arg constructor and seven overloaded single-argument constructors of type int, long, float, double, boolean, char, and Object.<br><br>&nbsp;&nbsp;&nbsp; \item For the first assert statement with no detail message, the no-arg constructor of \textbf{AssertionError} is used.<br><br>&nbsp;&nbsp;&nbsp; \item For the second assert statement with a detail message, an appropriate \textbf{AssertionError} constructor is used to match the data type of the message.<br><br>&nbsp;&nbsp;&nbsp; \item Since \textbf{AssertionError} is a subclass of \textbf{Error}, when an assertion becomes false, the program displays a message on the console and exits.<br>&nbsp;&nbsp;&nbsp; <br>\end{itemize}<br><br>[/latex]
Running programs with assertions	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item By default, the assertions are disabled at runtime.<br><br>&nbsp;&nbsp;&nbsp; \item To enable them, use the switch -enableassertions, or -ea for short as follows:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java -ea &lt;classfile&gt;<br><br>&nbsp;&nbsp;&nbsp; \item Assertions can be selectively enabled or disabled at class level or package level<br><br>&nbsp;&nbsp;&nbsp; \item The disable switch is -disableassertions or -da for short.<br><br>&nbsp;&nbsp;&nbsp; \item For example, the following command enables assertions in package package1 and disables assertions in class Class1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; java -ea:package1 -da:Class1 &lt;classfile&gt;<br><br>\end{itemize}<br><br>[/latex]
Using exception handling or assertions	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Assertions should not be used to replace exception handling.<br><br>&nbsp;&nbsp;&nbsp; \item Exception handling deals with unusual circumstances during program execution<br><br>&nbsp;&nbsp;&nbsp; \item Assertions are to assure the correctness of the program<br><br>&nbsp;&nbsp;&nbsp; \item Exception handling addresses robustness<br><br>&nbsp;&nbsp;&nbsp; \item Assertions address correctness<br><br>&nbsp;&nbsp;&nbsp; \item Like exception handling, assertions are not used for normal tests, but for internal consistency and validity checks.<br><br>&nbsp;&nbsp;&nbsp; \item Assertions are checked at runtime and can be turned on or off at startup time<br><br>&nbsp;&nbsp;&nbsp; \item Do not use assertions for argument checking in public methods<br><br>&nbsp;&nbsp;&nbsp; \item Valid arguments that may be passed to a public method are part of the methods contract<br><br>&nbsp;&nbsp;&nbsp; \item The contract must always be obeyed whether assertions are enabled or disabled<br><br>\end{itemize}<br><br>[/latex]
Programming with assertions	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Use assertions to reaffirm assumptions<br><br>&nbsp;&nbsp;&nbsp; \item This gives you more confidence to assure correctness of the program<br><br>&nbsp;&nbsp;&nbsp; \item A common use of assertions is to replace assumptions with assertion in the code<br><br>&nbsp;&nbsp;&nbsp; \item A best practice is to use assertions liberally<br><br>&nbsp;&nbsp;&nbsp; \item Assertions are checked at runtime and can be turned on or off at startup time, unlike exception handling.<br><br>\end{itemize}<br><br>[/latex]
Text I/O	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item In order to perform I/O, you need to create objects using appropriate Java I/O classes<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item The objects contain the methods for reading/writing data from/to a file<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; File<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Scanner<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrintWriter<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Absolute file names	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Absolute file name includes full path<br><br>\end{itemize}<br><br>[/latex]
Relative file names	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Relative file name includes path relative to working directory<br><br>\end{itemize}<br><br>[/latex]
The File class	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The File class is intended to provide an abstraction that deal with most of the machine-dependent complexities of files and path names in a machine-dependent fashion.<br><br>&nbsp;&nbsp;&nbsp; \item The file name is a string<br><br>&nbsp;&nbsp;&nbsp; \item The File class is a wrapper class for the file name and its directory path<br><br>\end{itemize}<br><br>[/latex]
File text I/O	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A File object encapsulates the properties of a file or a path, but does not contain the methods for reading/writing data from/to a file.<br><br>&nbsp;&nbsp;&nbsp; \item In order to perform I/O,&nbsp; you need to create objects using appropriate Java I/O classes<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item The objects contain the methods for reading/writing data from/to a file<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Use the \textbf{Scanner class} for reading text data from a file<br><br>&nbsp;&nbsp;&nbsp; \item Use the \textbf{PrintWriter class} for writing text data to a file<br><br>\end{itemize}<br><br>[/latex]
Reading data from the console	"[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Create a Scanner object<br><br>&nbsp;&nbsp;&nbsp; Scanner input = new Scanner(System.in);<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Example:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print(""Enter a double value: "");<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Scanner input = new Scanner(System.in);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double d = input.nextDouble();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]"
Reading data using Scanner	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Reading data from the console<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Scanner input = new Scanner(System.in);<br><br>&nbsp;&nbsp;&nbsp; \item Reading data from a file<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Scanner input = new Scanner(new File(filename));<br><br>\end{itemize}<br><br>[/latex]
Reading data from the internet	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Just like you can read data from a file on the computer, you can read data from a file on the internet<br><br>\end{itemize}<br><br>[/latex]
Use try-with-resources syntax	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item When reading or writing programmers often forget to close the file.<br><br>&nbsp;&nbsp;&nbsp; \item The \textbf{try-with-resources syntax} automatically closes the files.<br><br>\end{itemize}<br><br>[/latex]
Abstract classes	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Remember, a superclass defines common behavior for \textbf{related} subclasses<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Inheritance enables you to define a general class (i.e. a superclass) and later extend it to more specialized&nbsp; classes (i.e. subclasses)<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Sometimes, a superclass is so general it cannot be used to create objects<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Such a class is called an \textbf{abstract class}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item An \textbf{abstract} class can contain abstract methods that are implemented in \textbf{concrete} subclasses.<br><br>&nbsp;&nbsp;&nbsp; \item Just like nonabstract classes, models \textbf{is-a} relationships.<br><br>\end{itemize}<br><br>[/latex]
Abstract modifier	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Abstract classes and abstract methods are denoted using the \textbf{abstract} modifier<br><br>&nbsp;&nbsp;&nbsp; \item Constructors in an abstract class are \textbf{protected} because they are only used by subclasses.<br><br>\end{itemize}<br><br>[/latex]
Abstract methods are only allowed in abstract classes	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item An abstract method cannot be contained in a nonabstract class<br><br>&nbsp;&nbsp;&nbsp; \item If a subclass of an abstract superclass does not implement all the abstract methods, then the subclass must be defined abstract.<br><br>&nbsp;&nbsp;&nbsp; \item In other words, in a \textbf{nonabstract subclass} extended from an abstract class, \textbf{all} the abstract methods must be implemented, \textbf{even if they are not used in the subclass}.<br><br>\end{itemize}<br><br>[/latex]
An object cannot be created from an abstract class	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item An abstract class cannot be instantiated using the \textbf{new} operator.<br><br>&nbsp;&nbsp;&nbsp; \item You can still define its constructors, which are invoked in the constructors of its subclasses.<br><br>\end{itemize}<br><br>[/latex]
An abstract class without any abstract methods	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Remember, a class containing any abstract methods must be abstract<br><br>&nbsp;&nbsp;&nbsp; \item It is also possible to define an abstract class that does not contain any abstract methods<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item This class is used as a base class for defining a new subclass<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Superclass of abstract class may be concrete	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A subclass can be \textbf{abstract} even if its superclass is \textbf{concrete}<br><br>\end{itemize}<br><br>[/latex]
Concrete method overridden to be abstract	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A subclass can override a method from its superclass to define it abstract<br><br>&nbsp;&nbsp;&nbsp; \item \textbf{This is rare}, but useful when the implementation of the method in the superclass becomes invalid in the subclass<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item In this case the subclass must be define abstract<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Abstract class as a data type	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Remember, an abstract class cannot be instantiated using the new operator<br><br>&nbsp;&nbsp;&nbsp; \item However, an abstract class can be used as a data type.<br><br>\end{itemize}<br><br>[/latex]
Coherence	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A class should describe a single entity, and all the class operations should logically fit together to support a coherent purpose<br><br>&nbsp;&nbsp;&nbsp; \item A single entity with many responsibilities can be broken into several classes to separate responsibilities<br><br>\end{itemize}<br><br>[/latex]
Consistency	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Follow standard Java programming style and naming conventions<br><br>&nbsp;&nbsp;&nbsp; \item Choose informative names for classes, data fields, and methods<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Make names consistent<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Place the data declaration before the constructor, and place constructors before methods.<br><br>&nbsp;&nbsp;&nbsp; \item Provide a no-arg constructor (or document why the class does not support one)<br><br>\end{itemize}<br><br>[/latex]
Encapsulation	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A class should use the \textbf{private} modifier to hide its data from direct access by clients<br><br>&nbsp;&nbsp;&nbsp; \item Provide getter methods and setter methods to provide users with access to the private data, but only to private data you want the user to see or modify.<br><br>&nbsp;&nbsp;&nbsp; \item A class should also hide methods not intended for client use.<br><br>&nbsp;&nbsp;&nbsp; \item Make methods \textbf{protected} if they are intended for extenders of the class<br><br>\end{itemize}<br><br>[/latex]
Clarity and completeness	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A class should have a clear contract that is easy to explain and easy to understand<br><br>&nbsp;&nbsp;&nbsp; \item Design a class that imposes no restrictions on how or when the user can use it.<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Design properties in a way that lets the user set them in any order with any combination of values<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Design methods that function independently of their order of occurrence<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Methods should be defined intuitively without causing confusion<br><br>&nbsp;&nbsp;&nbsp; \item You should not declare a data field that can be derived from other data fields<br><br>&nbsp;&nbsp;&nbsp; \item A class should provide a variety of ways for customization through properties and methods that together are \textbf{minimal and complete}.<br><br>\end{itemize}<br><br>[/latex]
Instance vs. static	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A variable or method dependent on a \textbf{specific instannce} of the class must be an instance variable or method.<br><br>&nbsp;&nbsp;&nbsp; \item A variable shared by all instances of a class should be declared \textbf{static}<br><br>&nbsp;&nbsp;&nbsp; \item A method not dependent on a specific instance should be defined as a \textbf{static method}.<br><br>&nbsp;&nbsp;&nbsp; \item Always reference static variables and methods from a class name to improve readability and avoid errors. e.g:<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Class.staticVariable rather than Object.staticVariable<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item \textbf{Do not} initialize a static data field from a constructor parameter.<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Use a \textbf{setter method} to change the static data field<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Inheritance vs. aggregation	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Use \textbf{inheritance} to model \textbf{is-a} relationships<br><br>&nbsp;&nbsp;&nbsp; \item Use \textbf{aggregation (and composition)} to model \textbf{has-a} relationships<br><br>\end{itemize}<br><br>[/latex]
Abstract classes and interfaces	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Remember, a superclass defines common behavior for \textbf{related} subclasses<br><br>&nbsp;&nbsp;&nbsp; \item An \textbf{interface} can be used to define common behavior for classes, including \textbf{unrelated} classes.<br><br>&nbsp;&nbsp;&nbsp; \item Interfaces, and abstract classes are closely related to each other.<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \item An \textbf{abstract} class can contain abstract methods that are implemented in concrete subclasses<br><br>&nbsp;&nbsp;&nbsp; \item An \textbf{interface} is a class-like construct that contains constants and abstract methods<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item In many ways, an interface is similar to an abstract class, but the intent of an interface is to specify common behavior for \textbf{objects}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item For example, you can specify that the \textbf{objects} are comparable and/or cloneable using appropriate interfaces<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Defining an interface	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item To distinguish an interface from a class, Java uses the keyword \textbf{interface}<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item The syntax to define an interface is:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public interface InterfaceName \{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Constant declaration<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Abstract method signatures<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Interfaces	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item An interface is treated like a special class in Java<br><br>&nbsp;&nbsp;&nbsp; \item Each interface is compiled into a separate bytecode file, just like a regular class<br><br>&nbsp;&nbsp;&nbsp; \item Like an abstract class, you cannot create an instance from an interface using the \textbf{new} operator.<br><br>&nbsp;&nbsp;&nbsp; \item Naming convention<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Class names are nouns<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Interface names may be adjectives or nouns<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Interfaces model \textbf{is-kind-of} relationships<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item For example<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Fruit \textbf{is-kind-of} Edible<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \end{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The class for the object implementing an interface uses the keyword \textbf{implements}<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Examples:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abstract class Fruit implements Edible \{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Data fields, constructors, and methods<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class Chicken extends Animal implements Edible \{ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Data fields, constructors, and methods<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The relationship between the class and the interface is known as \textbf{interface inheritance}<br><br>\end{itemize}<br><br>[/latex]
Omitting modifiers in interfaces	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item \textbf{All data fields} are public final static and \textbf{all methods} are public abstract in an interface.<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item As such, these modifiers can be omitted.<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
Interface static members	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Interfaces can have static members<br><br>&nbsp;&nbsp;&nbsp; \item Like class static members, the best practice is to make invocations of static methods and access of static data fields obvious.<br><br>&nbsp;&nbsp;&nbsp; \item Use<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InterfaceName.methodName(arguments)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InterfaceName.variable<br><br>\end{itemize}<br><br>[/latex]
Interface default methods	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A default method provides a default implementation for the method in the interface<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Use the keyword \textbf{default}<br><br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A class that implements the interface may simply use the default implementation for the method or override the method with a new implementation.<br><br>\end{itemize}<br><br>[/latex]
Interface example	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The \textit{java.lang.Comparable} interface defines the compareTo method for comparing objects<br><br>&nbsp;&nbsp;&nbsp; \item Many classes (e.g. the numeric wrapper classes) in the Java library implement Comparable to define a natural order for objects<br><br>&nbsp;&nbsp;&nbsp; \item The \textit{java.lang.Cloneable} interface specifies that an object can be cloned (i.e., it can be copied)<br><br>&nbsp;&nbsp;&nbsp; \item The interface is empty<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item An interface with an empty body is called a \textbf{marker interface}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A class that implements the Cloneable interface is \textbf{marked} cloneable<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Its objects can be cloned using the clone method \textbf{defined in the Object class}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
The Cloneable interface	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Like Comparable, many classes in the Java library implement Cloneable<br><br>&nbsp;&nbsp;&nbsp; \item Arrays are cloneable<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item You can clone an array using the clone method<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int[] list1 = \{ 1,2 \}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int[] list2 = list1.clone();<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item ArrayList implements Cloneable<br><br>\end{itemize}<br><br>[/latex]
Defining classes to implement Cloneable	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item A class that implements the Cloneable interface must override the clone method defined in the Object class<br><br>&nbsp;&nbsp;&nbsp; \item The keyword \textbf{native} indicates this method is not written in Java<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item It is implemented in the JVM for the native platform<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item The class must override the clone method and change the visibility modifier to public, so it can be used in any package.<br><br>&nbsp;&nbsp;&nbsp; \item The class must implement Cloneable<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Otherwise, CloneNotSupportedException is thrown<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item To perform a \textbf{shallow copy}, the clone method in a class that implements the Cloneable interface can simply invoke the super.clone method<br><br>&nbsp;&nbsp;&nbsp; \item To perform a \textbf{deep copy}, the clone method in a class that implements the Cloneable interface must copy the contents of data fields that are objects.<br><br>\end{itemize}<br><br>[/latex]
Interfaces vs. abstract classes	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item In an interface, the data must be constants; an abstract class can have all types of data<br><br>&nbsp;&nbsp;&nbsp; \item Each method in an interface has only a signature without implementation (except default and static methods); an abstract class can have concrete methods<br><br>&nbsp;&nbsp;&nbsp; \item An interface can inherit other interfaces using the \textbf{extends} keyword. Such an interface is called a \textbf{subinterface}.<br><br>&nbsp;&nbsp;&nbsp; \item A class implementing a subinterface must implement the abstract methods defined in it and all the interfaces that the subinterface extends from.<br><br>&nbsp;&nbsp;&nbsp; \item An interface can extend other interfaces, but not classes<br><br>&nbsp;&nbsp;&nbsp; \item All classes share a single root, the Object class, but \textbf{there is no single root for interfaces}<br><br>&nbsp;&nbsp;&nbsp; \item Like a class, an interface also defineds a type<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item A variable of an interface type can reference any instance of the class that implements the interface<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item If interface 2 extends interface 1, then interface 1 is like a superclass for interface 2<br><br>&nbsp;&nbsp;&nbsp; \item You can use an interface as a data type and cast a variable of an interface type to its subclass and vice versa.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \item A class can implement multiple interfaces, but it can only extend one superclass.<br><br>\end{itemize}<br><br>[/latex]
Conflicting interfaces	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item On rare occasion, a class may implement two interfaces with conflicting information (e.g., two same constants with different values or two methods with same signature but different return type)<br><br>&nbsp;&nbsp;&nbsp; \item This type of errors will be detected by the compiler<br><br>\end{itemize}<br><br>[/latex]
Interfaces vs. abstract classes 2	[latex]<br><br>\begin{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item Abstract classes and interfaces can both be used to model common behavior for objects<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item Interfaces cannot contain data fields only constants<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item In general, a strong \textbf{is-a} relationship clearly describes a parent-child relationship should be modeled using \textbf{classes}.<br><br>&nbsp;&nbsp;&nbsp; \item An \textbf{is-kind-of} relationship indicates an object possesses a certain property and can be modeled using \textbf{interfaces}<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item An interface can define a common supertype for \textbf{unrelated classes}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>&nbsp;&nbsp;&nbsp; \item \textbf{A subclass can extend only one superclass, but can implement any number of interfaces}<br><br>&nbsp;&nbsp;&nbsp; \item You can also use interfaces to circumvent single inheritance restriction if multiple inheritance is desired.<br><br>&nbsp;&nbsp;&nbsp; \begin{itemize}<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \item You must design one as a superclass, and others as interface<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; \end{itemize}<br><br>\end{itemize}<br><br>[/latex]
